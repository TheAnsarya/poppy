# 🎮 Game Boy Development with Poppy

Complete guide to developing Game Boy (DMG/CGB) games with the Poppy assembler.

---

## 📚 Table of Contents

- [Getting Started](#getting-started)
- [SM83 Instruction Set](#sm83-instruction-set)
- [Memory Organization](#memory-organization)
- [ROM Header Configuration](#rom-header-configuration)
- [Memory Bank Controllers](#memory-bank-controllers)
- [Color Game Boy Features](#color-game-boy-features)
- [Examples](#examples)
- [Resources](#resources)

---

## 🚀 Getting Started

### Basic Hello World

```asm
.target gameboy

; ROM Header
.gb_title "HELLO"
.gb_licensee "01"  ; Nintendo
.gb_mbc MBC1       ; Memory Bank Controller type
.gb_romsize 2      ; 64KB
.gb_ramsize 0      ; No RAM

; Entry point (execution starts at $0150)
.org $0150
start:
	; Disable interrupts
	di
	
	; Initialize stack pointer
	ld sp, $fffe
	
	; Turn off LCD
	call wait_vblank
	xor a
	ldh ($ff40), a  ; LCDC = 0 (LCD off)
	
	; Clear VRAM
	ld hl, $8000
	ld bc, $2000
clear_vram:
	xor a
	ld (hl+), a
	dec bc
	ld a, b
	or c
	jr nz, clear_vram
	
	; Enable LCD
	ld a, $91       ; LCD on, BG on
	ldh ($ff40), a
	
main_loop:
	halt
	jr main_loop

wait_vblank:
	ldh a, ($ff44)  ; LY register
	cp 144
	jr nz, wait_vblank
	ret
```

---

## 🔧 SM83 Instruction Set

The Game Boy uses the Sharp SM83 processor, similar to the Z80 but with differences.

### 8-bit Loads

```asm
ld a, $42       ; Load immediate
ld a, b         ; Register to register
ld a, (hl)      ; Load from memory pointed by HL
ld (hl), a      ; Store to memory pointed by HL
ldh ($ff80), a  ; Load to high RAM ($ff00 + offset)
ldh a, ($ff44)  ; Load from high RAM
```

### 16-bit Loads

```asm
ld bc, $1234    ; Load 16-bit immediate
ld hl, sp+5     ; HL = SP + signed offset
ld sp, hl       ; SP = HL
push bc         ; Push BC onto stack
pop de          ; Pop from stack into DE
```

### Arithmetic

```asm
add a, b        ; A = A + B
adc a, c        ; A = A + C + carry
sub d           ; A = A - D
sbc a, e        ; A = A - E - carry
and h           ; A = A & H
or l            ; A = A | L
xor a           ; A = A ^ A (clear A)
cp $80          ; Compare A with $80
inc a           ; Increment A
dec b           ; Decrement B
```

### 16-bit Arithmetic

```asm
add hl, bc      ; HL = HL + BC
inc bc          ; BC = BC + 1
dec de          ; DE = DE - 1
```

### Bit Operations

```asm
rlca            ; Rotate A left circular
rrca            ; Rotate A right circular
rla             ; Rotate A left through carry
rra             ; Rotate A right through carry
```

### CB-Prefixed Bit Operations

```asm
rlc b           ; Rotate B left circular
rrc c           ; Rotate C right circular
rl d            ; Rotate D left through carry
rr e            ; Rotate E right through carry
sla h           ; Shift H left arithmetic
sra l           ; Shift L right arithmetic
swap a          ; Swap nibbles of A
srl b           ; Shift B right logical

bit 0, c        ; Test bit 0 of C
res 1, d        ; Reset bit 1 of D
set 2, e        ; Set bit 2 of E
```

### Jumps and Calls

```asm
jp $4000        ; Jump absolute
jp hl           ; Jump to address in HL
jr label        ; Jump relative (±127 bytes)
jr z, label     ; Jump if zero
jr nz, label    ; Jump if not zero
jr c, label     ; Jump if carry
jr nc, label    ; Jump if not carry
call $5000      ; Call subroutine
ret             ; Return from subroutine
ret z           ; Return if zero
reti            ; Return and enable interrupts
```

### Stack Operations

```asm
push af         ; Push AF onto stack
push bc         ; Push BC onto stack
pop de          ; Pop into DE
pop hl          ; Pop into HL
```

### Special Instructions

```asm
nop             ; No operation
halt            ; Halt until interrupt
stop            ; Stop CPU and LCD
di              ; Disable interrupts
ei              ; Enable interrupts
daa             ; Decimal adjust A
cpl             ; Complement A
scf             ; Set carry flag
ccf             ; Complement carry flag
```

---

## 🗺️ Memory Organization

### Memory Map

```
$0000-$00ff : RST vectors and interrupt handlers
$0100-$014f : ROM header (auto-generated by Poppy)
$0150-$3fff : ROM Bank 0 (fixed)
$4000-$7fff : ROM Bank 1-N (switchable via MBC)
$8000-$97ff : Tile data
$9800-$9bff : Background map 0
$9c00-$9fff : Background map 1
$a000-$bfff : External RAM (switchable via MBC)
$c000-$cfff : Work RAM bank 0
$d000-$dfff : Work RAM bank 1 (CGB: switchable)
$e000-$fdff : Echo RAM (mirror of $c000-$ddff)
$fe00-$fe9f : Object Attribute Memory (OAM)
$fea0-$feff : Unusable
$ff00-$ff7f : I/O registers
$ff80-$fffe : High RAM (HRAM)
$ffff       : Interrupt enable register
```

### VRAM Organization

```asm
; Tile Data Area ($8000-$97ff)
; Each tile is 16 bytes (8x8 pixels, 2 bits per pixel)
.org $8000
tile_data:
	; Tile 0
	.byte $3c, $7e, $42, $42, $42, $42, $42, $42
	.byte $42, $42, $42, $42, $42, $42, $7e, $3c

; Background Map 0 ($9800-$9bff)
; 32x32 tile indices
.org $9800
bg_map:
	.byte $00, $01, $02, $03  ; Row 0
	; ... (32x32 = 1024 tiles total)
```

### Work RAM (WRAM)

```asm
; Variables in WRAM
.org $c000
player_x:       .res 1
player_y:       .res 1
score:          .res 2  ; 16-bit score
lives:          .res 1
game_state:     .res 1
```

### High RAM (HRAM)

Fast zero-page style RAM ($ff80-$fffe):

```asm
; Use for frequently accessed variables
.org $ff80
temp_a:         .res 1
temp_bc:        .res 2
frame_counter:  .res 1
```

### Object Attribute Memory (OAM)

Sprite data ($fe00-$fe9f):

```asm
; Each sprite is 4 bytes: Y, X, Tile#, Attributes
; 40 sprites max (160 bytes)
.org $fe00
sprite_0_y:     .byte 16
sprite_0_x:     .byte 8
sprite_0_tile:  .byte $00
sprite_0_attr:  .byte $00
```

---

## 📋 ROM Header Configuration

The Game Boy ROM header is automatically generated and placed at $0100-$014f.

### Header Directives

```asm
.target gameboy

; Title (up to 16 characters)
.gb_title "MY GAME"

; Old licensee code (use "33" for new licensee)
.gb_licensee "01"

; New licensee code (required if old licensee is "33")
.gb_new_licensee "AB"

; Memory Bank Controller type
.gb_mbc NONE        ; No MBC (32KB max)
.gb_mbc MBC1        ; MBC1 (up to 2MB ROM, 32KB RAM)
.gb_mbc MBC3_RTC    ; MBC3 with RTC
.gb_mbc MBC5        ; MBC5 (up to 8MB ROM, 128KB RAM)

; ROM size (in banks)
; 0 = 32KB (2 banks)
; 1 = 64KB (4 banks)
; 2 = 128KB (8 banks)
; 3 = 256KB (16 banks)
; 4 = 512KB (32 banks)
; 5 = 1MB (64 banks)
; 6 = 2MB (128 banks)
; 7 = 4MB (256 banks)
.gb_romsize 2       ; 128KB

; RAM size
; 0 = None
; 1 = Unused
; 2 = 8KB
; 3 = 32KB (4 banks)
; 4 = 128KB (16 banks)
; 5 = 64KB (8 banks)
.gb_ramsize 3       ; 32KB

; CGB (Color Game Boy) mode
.gb_cgb DMG_ONLY         ; Original GB only (default)
.gb_cgb CGB_COMPATIBLE   ; Works on both
.gb_cgb CGB_ONLY         ; Requires CGB

; SGB (Super Game Boy) enhanced
.gb_sgb true             ; Enable SGB features
```

### Header Fields (Auto-Generated)

The header includes these automatically:

- **Entry point** ($0100-$0103): `nop; jp $0150`
- **Nintendo logo** ($0104-$0133): Required bitmap
- **Title** ($0134-$0143): From `.gb_title`
- **CGB flag** ($0143): From `.gb_cgb`
- **New licensee** ($0144-$0145): From `.gb_new_licensee`
- **SGB flag** ($0146): From `.gb_sgb`
- **Cartridge type** ($0147): From `.gb_mbc`
- **ROM size** ($0148): From `.gb_romsize`
- **RAM size** ($0149): From `.gb_ramsize`
- **Destination** ($014a): $01 (non-Japanese)
- **Old licensee** ($014b): From `.gb_licensee`
- **Version** ($014c): $00
- **Header checksum** ($014d): Auto-calculated
- **Global checksum** ($014e-$014f): Auto-calculated

---

## 🎛️ Memory Bank Controllers

MBCs enable ROMs larger than 32KB by bank switching.

### MBC1 (Most Common)

```asm
.gb_mbc MBC1
.gb_romsize 4       ; 512KB (32 banks)
.gb_ramsize 3       ; 32KB (4 banks)

; ROM bank switching
switch_rom_bank:
	ld a, 5         ; Switch to bank 5
	ld ($2000), a   ; Write to $2000-$3fff
	ret

; RAM enable/disable
enable_ram:
	ld a, $0a       ; Magic value
	ld ($0000), a   ; Write to $0000-$1fff
	ret

disable_ram:
	xor a
	ld ($0000), a
	ret

; RAM bank switching (if >8KB)
switch_ram_bank:
	ld a, 2         ; Switch to RAM bank 2
	ld ($4000), a   ; Write to $4000-$5fff
	ret
```

### MBC3 (With RTC)

```asm
.gb_mbc MBC3_RTC

; Access RTC registers
latch_rtc:
	xor a
	ld ($6000), a   ; Latch RTC
	ld a, 1
	ld ($6000), a
	ret

read_rtc_seconds:
	ld a, $08       ; RTC seconds register
	ld ($4000), a   ; Select RTC register
	ld a, ($a000)   ; Read value
	ret
```

### MBC5 (Largest ROMs)

```asm
.gb_mbc MBC5
.gb_romsize 7       ; 4MB (256 banks)

; 9-bit bank number (0-511)
switch_rom_bank:
	ld a, bank & $ff    ; Low 8 bits
	ld ($2000), a
	ld a, bank >> 8     ; High bit
	ld ($3000), a
	ret
```

---

## 🌈 Color Game Boy Features

### CGB Mode Selection

```asm
; DMG only (original GB, no color)
.gb_cgb DMG_ONLY

; CGB compatible (works on both DMG and CGB)
.gb_cgb CGB_COMPATIBLE

; CGB only (requires Color GB)
.gb_cgb CGB_ONLY
```

### CGB Color Palettes

```asm
; Background palette data
bg_palette_data:
	; Palette 0 (4 colors, 2 bytes each)
	.word $7fff  ; White (RGB555: 11111 11111 11111)
	.word $5294  ; Light gray
	.word $294a  ; Dark gray
	.word $0000  ; Black

; Set background palette
set_bg_palette:
	ld a, $80       ; Auto-increment, palette 0
	ldh ($ff68), a  ; BCPS (palette index)
	
	ld hl, bg_palette_data
	ld b, 8         ; 8 bytes (4 colors)
.loop:
	ld a, (hl+)
	ldh ($ff69), a  ; BCPD (palette data)
	dec b
	jr nz, .loop
	ret
```

### VRAM Bank Switching

CGB has 2 VRAM banks ($8000-$9fff each):

```asm
; Switch to VRAM bank 1
switch_vram_bank_1:
	ld a, 1
	ldh ($ff4f), a  ; VBK (VRAM bank)
	ret

; Switch back to bank 0
switch_vram_bank_0:
	xor a
	ldh ($ff4f), a
	ret
```

### WRAM Bank Switching

CGB has 8 WRAM banks ($d000-$dfff each):

```asm
; Switch to WRAM bank 3
switch_wram_bank:
	ld a, 3
	ldh ($ff70), a  ; SVBK (WRAM bank)
	ret
```

---

## 📦 Examples

### Complete Minimal ROM

```asm
.target gameboy

.gb_title "MINIMAL"
.gb_mbc NONE
.gb_romsize 0    ; 32KB
.gb_ramsize 0    ; No RAM

.org $0150
start:
	di
	ld sp, $fffe
	
	; Turn off LCD
	call wait_vblank
	xor a
	ldh ($ff40), a
	
	; Turn LCD back on
	ld a, $91
	ldh ($ff40), a
	ei

main_loop:
	halt
	jr main_loop

wait_vblank:
	ldh a, ($ff44)
	cp 144
	jr nz, wait_vblank
	ret
```

### Using External RAM

```asm
.target gameboy

.gb_title "SAVEGAME"
.gb_mbc MBC1
.gb_romsize 1    ; 64KB
.gb_ramsize 2    ; 8KB

.org $0150
start:
	; Enable RAM
	ld a, $0a
	ld ($0000), a
	
	; Write to RAM
	ld hl, $a000
	ld a, $42
	ld (hl), a
	
	; Disable RAM
	xor a
	ld ($0000), a
	ret
```

---

## 📚 Resources

### Documentation
- [Pan Docs](https://gbdev.io/pandocs/) - Complete GB technical reference
- [GB ASM Tutorial](https://eldred.fr/gb-asm-tutorial/) - Comprehensive tutorial
- [GB Opcode Map](https://www.pastraiser.com/cpu/gameboy/gameboy_opcodes.html)

### Tools
- [BGB](https://bgb.bircd.org/) - Excellent GB/GBC emulator with debugger
- [Emulicious](https://emulicious.net/) - Multi-system emulator with debugging
- [GBTD/GBMB](http://www.devrs.com/gb/hmgd/gbtd.html) - Tile and map editors

### Libraries
- [hardware.inc](https://github.com/gbdev/hardware.inc) - Hardware register definitions
- [GB Dev Resources](https://gbdev.io/) - Community resources

---

## ⚡ Best Practices

1. **Always wait for VBLANK** before accessing VRAM
2. **Use HRAM** for frequently accessed variables
3. **Disable interrupts** during critical sections
4. **Test on real hardware** or accurate emulators
5. **Use MBC3/MBC5** for new projects (MBC1 has quirks)
6. **Enable RAM only when needed** to save battery
7. **Use CGB_COMPATIBLE** for widest compatibility

---

**See Also:**
- [User Manual](user-manual.md) - General Poppy usage
- [Syntax Specification](syntax-spec.md) - Assembly syntax
- [Migration from ca65](migration-from-ca65.md)
