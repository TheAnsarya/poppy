// ============================================================================
// OutputVerificationTests.cs - Tests that verify actual code output
// Poppy Compiler - Multi-system Assembly Compiler
// ============================================================================
// These tests verify that code generates the expected byte sequences,
// not just that compilation succeeds without errors.
// ============================================================================

using Poppy.Core.CodeGen;
using Poppy.Core.Semantics;
using Xunit;

using PoppyLexer = Poppy.Core.Lexer.Lexer;
using PoppyParser = Poppy.Core.Parser.Parser;

namespace Poppy.Tests.Integration;

/// <summary>
/// Integration tests that verify actual byte output matches expected values.
/// These tests ensure features work correctly, not just that they don't crash.
/// </summary>
public class OutputVerificationTests {
	/// <summary>
	/// Helper to compile source and return generated bytes.
	/// </summary>
	private static (byte[] Code, CodeGenerator Generator, SemanticAnalyzer Analyzer) Compile(string source) {
		var lexer = new PoppyLexer(source);
		var tokens = lexer.Tokenize();
		var parser = new PoppyParser(tokens);
		var program = parser.Parse();

		var analyzer = new SemanticAnalyzer();
		analyzer.Analyze(program);

		var generator = new CodeGenerator(analyzer);
		var code = generator.Generate(program);

		return (code, generator, analyzer);
	}

	// ========================================================================
	// Conditional Assembly Output Verification
	// ========================================================================

	[Fact]
	public void Conditional_IfTrue_GeneratesNop() {
		var source = @"
.if 1
	nop
.endif
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xea], code); // NOP opcode
	}

	[Fact]
	public void Conditional_IfFalse_GeneratesNoCode() {
		var source = @"
.if 0
	nop
.endif
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Empty(code); // Nothing generated - condition false
	}

	[Fact]
	public void Conditional_IfTrueElse_GeneratesThenBranch() {
		var source = @"
.if 1
	nop
.else
	brk
.endif
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xea], code); // NOP only, not BRK
	}

	[Fact]
	public void Conditional_IfFalseElse_GeneratesElseBranch() {
		var source = @"
.if 0
	nop
.else
	brk
.endif
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0x00], code); // BRK only, not NOP
	}

	[Fact]
	public void Conditional_WithSymbolExpression_GeneratesCorrectBranch() {
		var source = @"
DEBUG = 1
RELEASE = 0

.if DEBUG
	lda #$ff  ; debug value
.else
	lda #$00  ; release value
.endif
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xa9, 0xff], code); // LDA #$ff (debug value)
	}

	[Fact]
	public void Conditional_ElseIfBranch_GeneratesCorrectCode() {
		var source = @"
MODE = 2

.if MODE == 1
	lda #$01
.elseif MODE == 2
	lda #$02
.else
	lda #$03
.endif
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xa9, 0x02], code); // LDA #$02 (mode 2)
	}

	// ========================================================================
	// Macro Expansion Output Verification
	// ========================================================================

	[Fact]
	public void Macro_SimpleTwoNops_GeneratesTwoNopBytes() {
		var source = @"
.macro two_nops
	nop
	nop
.endmacro

@two_nops
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xea, 0xea], code); // Two NOP opcodes
	}

	[Fact]
	public void Macro_WithParameter_SubstitutesValue() {
		var source = @"
.macro load_immediate value
	lda #value
.endmacro

@load_immediate $42
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xa9, 0x42], code); // LDA #$42
	}

	[Fact]
	public void Macro_WithMultipleParameters_AllSubstituted() {
		var source = @"
.macro store_value addr, value
	lda #value
	sta addr
.endmacro

@store_value $0200, $ff
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xa9, 0xff, 0x8d, 0x00, 0x02], code);
		// LDA #$ff (a9 ff) + STA $0200 (8d 00 02)
	}

	[Fact]
	public void Macro_DefaultParameter_UsesDefaultWhenOmitted() {
		var source = @"
.macro load_value value = $00
	lda #value
.endmacro

@load_value
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xa9, 0x00], code); // LDA #$00 (default)
	}

	[Fact]
	public void Macro_DefaultParameter_UsesProvidedWhenGiven() {
		var source = @"
.macro load_value value = $00
	lda #value
.endmacro

@load_value $42
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xa9, 0x42], code); // LDA #$42 (provided)
	}

	[Fact]
	public void Macro_MultipleInvocations_AllExpanded() {
		var source = @"
.macro inc_a
	clc
	adc #$01
.endmacro

lda #$00
@inc_a
@inc_a
@inc_a
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		// LDA #$00 (a9 00) + 3x (CLC ADC #$01 = 18 69 01)
		Assert.Equal([0xa9, 0x00, 0x18, 0x69, 0x01, 0x18, 0x69, 0x01, 0x18, 0x69, 0x01], code);
	}

	// ========================================================================
	// Repeat Block Output Verification
	// ========================================================================

	[Fact]
	public void Repeat_ThreeNops_GeneratesThreeNopBytes() {
		var source = @"
.rept 3
	nop
.endr
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xea, 0xea, 0xea], code); // Three NOP opcodes
	}

	[Fact]
	public void Repeat_ZeroTimes_GeneratesNoCode() {
		var source = @"
.rept 0
	nop
.endr
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Empty(code); // No repetitions
	}

	[Fact]
	public void Repeat_WithData_GeneratesRepeatedData() {
		var source = @"
.rept 4
	.byte $ff
.endr
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xff, 0xff, 0xff, 0xff], code);
	}

	// ========================================================================
	// Enumeration Output Verification
	// ========================================================================

	[Fact]
	public void Enum_DefinedValues_UsableInCode() {
		var source = @"
.enum $00
	PLAYER_X
	PLAYER_Y
.ende

lda PLAYER_X
lda PLAYER_Y
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		// LDA $00 (a5 00) + LDA $01 (a5 01) - zero page addressing
		Assert.Equal([0xa5, 0x00, 0xa5, 0x01], code);
	}

	// ========================================================================
	// Data Directive Output Verification
	// ========================================================================

	[Fact]
	public void Byte_SingleValue_GeneratesByte() {
		var source = ".byte $42";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0x42], code);
	}

	[Fact]
	public void Byte_MultipleValues_GeneratesSequence() {
		var source = ".byte $01, $02, $03, $04";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0x01, 0x02, 0x03, 0x04], code);
	}

	[Fact]
	public void Word_SingleValue_GeneratesLittleEndian() {
		var source = ".word $1234";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0x34, 0x12], code); // Little-endian
	}

	[Fact]
	public void Word_MultipleValues_GeneratesSequence() {
		var source = ".word $1234, $5678";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0x34, 0x12, 0x78, 0x56], code);
	}

	// ========================================================================
	// Symbol Expression Output Verification
	// ========================================================================

	[Fact]
	public void Symbol_InImmediate_ResolvesCorrectly() {
		var source = @"
VALUE = $42
lda #VALUE
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xa9, 0x42], code);
	}

	[Fact]
	public void Symbol_Expression_EvaluatesCorrectly() {
		var source = @"
BASE = $10
OFFSET = $05
lda #BASE + OFFSET
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xa9, 0x15], code); // $10 + $05 = $15
	}

	// ========================================================================
	// Label Reference Output Verification
	// ========================================================================

	[Fact]
	public void Label_JmpAbsolute_EncodesCorrectAddress() {
		var source = @"
.org $8000
start:
	jmp start
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0x4c, 0x00, 0x80], code); // JMP $8000
	}

	[Fact]
	public void Label_ForwardReference_ResolvesCorrectly() {
		var source = @"
.org $8000
	jmp target
	nop
	nop
target:
	rts
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		// JMP $8005 (4c 05 80) + NOP (ea) + NOP (ea) + RTS (60)
		Assert.Equal([0x4c, 0x05, 0x80, 0xea, 0xea, 0x60], code);
	}

	// ========================================================================
	// Combined Feature Output Verification
	// ========================================================================

	[Fact]
	public void MacroInConditional_GeneratesCorrectCode() {
		var source = @"
DEBUG = 1

.macro debug_break
	brk
	nop
.endmacro

.if DEBUG
	@debug_break
.endif
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0x00, 0xea], code); // BRK + NOP from macro in conditional
	}

	[Fact]
	public void MacroWithDataDirectives_GeneratesCorrectBytes() {
		var source = @"
.macro define_sprite tile, x, y
	.byte y
	.byte tile
	.byte $00   ; attributes
	.byte x
.endmacro

@define_sprite $01, $80, $60
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0x60, 0x01, 0x00, 0x80], code);
	}

	[Fact]
	public void NestedConditionals_GeneratesCorrectBranch() {
		var source = @"
OUTER = 1
INNER = 0

.if OUTER
	nop
	.if INNER
		brk
	.else
		clc
	.endif
.endif
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xea, 0x18], code); // NOP + CLC (not BRK)
	}
}
