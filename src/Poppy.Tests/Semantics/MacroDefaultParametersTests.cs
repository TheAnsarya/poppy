using Poppy.Core.CodeGen;
using Poppy.Core.Lexer;
using Poppy.Core.Parser;
using Poppy.Core.Semantics;
using Xunit;

namespace Poppy.Tests.Semantics;

/// <summary>
/// Tests for macro default parameters feature.
/// Verifies that macros can define default parameter values and use them
/// when arguments are not provided during invocation.
/// </summary>
public class MacroDefaultParametersTests {
	/// <summary>
	/// Helper to compile source and return generated bytes.
	/// </summary>
	private static (byte[] Code, CodeGenerator Generator, SemanticAnalyzer Analyzer) Compile(string source) {
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		var analyzer = new SemanticAnalyzer(TargetArchitecture.MOS6502);
		analyzer.Analyze(program);

		var generator = new CodeGenerator(analyzer);
		var code = generator.Generate(program);

		return (code, generator, analyzer);
	}

	[Fact]
	public void MacroDefaultParameter_SingleParameter_UsesDefault() {
		var source = @"
.macro load_default value=$42
	lda #value
.endmacro

@load_default
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		// LDA immediate with default value $42
		Assert.Equal([0xa9, 0x42], code);
	}

	[Fact]
	public void MacroDefaultParameter_SingleParameter_OverrideDefault() {
		var source = @"
.macro load_default value=$42
	lda #value
.endmacro

@load_default $ff
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		// LDA immediate with overridden value $FF
		Assert.Equal([0xa9, 0xff], code);
	}

	[Fact]
	public void MacroDefaultParameter_MultipleDefaults_AllUsed() {
		var source = @"
.macro init_sprite x=$00, y=$00, tile=$01
	lda #x
	sta $0200
	lda #y
	sta $0201
	lda #tile
	sta $0202
.endmacro

@init_sprite
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		// LDA #$00, STA $0200, LDA #$00, STA $0201, LDA #$01, STA $0202
		Assert.Equal([
			0xa9, 0x00, // LDA #$00
			0x8d, 0x00, 0x02, // STA $0200
			0xa9, 0x00, // LDA #$00
			0x8d, 0x01, 0x02, // STA $0201
			0xa9, 0x01, // LDA #$01
			0x8d, 0x02, 0x02  // STA $0202
		], code);
	}

	[Fact]
	public void MacroDefaultParameter_MultipleDefaults_PartialOverride() {
		var source = @"
.macro init_sprite x=$00, y=$00, tile=$01
	lda #x
	sta $0200
	lda #y
	sta $0201
	lda #tile
	sta $0202
.endmacro

@init_sprite $10, $20
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		// LDA #$10, STA $0200, LDA #$20, STA $0201, LDA #$01, STA $0202
		Assert.Equal([
			0xa9, 0x10, // LDA #$10 (overridden)
			0x8d, 0x00, 0x02, // STA $0200
			0xa9, 0x20, // LDA #$20 (overridden)
			0x8d, 0x01, 0x02, // STA $0201
			0xa9, 0x01, // LDA #$01 (default)
			0x8d, 0x02, 0x02  // STA $0202
		], code);
	}

	[Fact]
	public void MacroDefaultParameter_MixedRequiredAndOptional() {
		var source = @"
sprite_buffer = $0200

.macro sprite_dma addr, count=$40, channel=$00
	lda #>addr
	sta $2003
	lda #<addr
	sta $2004
	ldx #count
	ldy #channel
.endmacro

@sprite_dma sprite_buffer
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		// LDA #>$0200, STA $2003, LDA #<$0200, STA $2004, LDX #$40, LDY #$00
		Assert.Equal([
			0xa9, 0x02, // LDA #$02 (high byte of $0200)
			0x8d, 0x03, 0x20, // STA $2003
			0xa9, 0x00, // LDA #$00 (low byte of $0200)
			0x8d, 0x04, 0x20, // STA $2004
			0xa2, 0x40, // LDX #$40 (default)
			0xa0, 0x00  // LDY #$00 (default)
		], code);
	}

	[Fact]
	public void MacroDefaultParameter_MixedRequiredAndOptional_AllProvided() {
		// arrange
		var source = @"
sprite_buffer = $0200

.macro sprite_dma addr, count=$40, channel=$00
	lda #>addr
	sta $2003
	lda #<addr
	sta $2004
	ldx #count
	ldy #channel
.endmacro

@sprite_dma sprite_buffer, $80, $01
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		var analyzer = new SemanticAnalyzer(TargetArchitecture.MOS6502);
		analyzer.Analyze(program);

		// assert - all parameters provided
		Assert.False(analyzer.HasErrors);
	}

	[Fact]
	public void MacroDefaultParameter_ExpressionAsDefault() {
		// arrange
		var source = @"
BUFFER_SIZE = 256

.macro fill_buffer value=$00, count=BUFFER_SIZE
	ldx #count
	lda #value
	sta $0200
.endmacro

@fill_buffer
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		var analyzer = new SemanticAnalyzer(TargetArchitecture.MOS6502);
		analyzer.Analyze(program);

		// assert - expression defaults should work
		Assert.False(analyzer.HasErrors);
	}

	[Fact]
	public void MacroDefaultParameter_MissingRequiredParameter_ReportsError() {
		// arrange
		var source = @"
.macro sprite_dma addr, count=$40, channel=$00
	lda #>addr
	sta $2003
.endmacro

@sprite_dma
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		var analyzer = new SemanticAnalyzer(TargetArchitecture.MOS6502);
		analyzer.Analyze(program);

		// assert - missing required parameter should report error
		Assert.True(analyzer.HasErrors);
	}

	[Fact]
	public void MacroDefaultParameter_BackwardCompatibility_NoDefaults() {
		// arrange - existing macro syntax without defaults should still work
		var source = @"
.macro simple_macro param1, param2
	lda param1
	sta param2
.endmacro

@simple_macro #$42, $2000
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		var analyzer = new SemanticAnalyzer(TargetArchitecture.MOS6502);
		analyzer.Analyze(program);

		// assert - existing macros should continue to work
		Assert.False(analyzer.HasErrors);
	}

	[Fact]
	public void MacroDefaultParameter_OnlyOptionalParameters() {
		// arrange - simplified macro to test defaults
		var source = @"
.macro load_value value=$01
	lda #value
.endmacro

@load_value
@load_value $10
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		var analyzer = new SemanticAnalyzer(TargetArchitecture.MOS6502);
		analyzer.Analyze(program);

		// DEBUG: Output errors
		if (analyzer.HasErrors) {
			foreach (var e in analyzer.Errors) {
				Console.WriteLine($"ERROR: {e}");
			}
		}

		// assert - macro with all optional params should work
		Assert.False(analyzer.HasErrors);
	}

	[Fact]
	public void MacroDefaultParameter_DefaultsAfterRequired() {
		// arrange - test common pattern: required params first, defaults after
		var source = @"
.macro ppu_write addr, value, count=$01
	bit $2002
	lda #>addr
	sta $2006
	lda #<addr
	sta $2006
	lda #value
	ldx #count
	sta $2007
.endmacro

@ppu_write $2000, $ff
@ppu_write $2000, $00, $20
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		var analyzer = new SemanticAnalyzer(TargetArchitecture.MOS6502);
		analyzer.Analyze(program);

		// assert - should work with both invocations
		Assert.False(analyzer.HasErrors);
	}

	[Fact]
	public void MacroDefaultParameter_HexValueAsDefault() {
		// arrange
		var source = @"
.macro set_byte addr=$2000, value=$ff
	lda #value
	sta addr
.endmacro

@set_byte
@set_byte $3000
@set_byte $3000, $42
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		var analyzer = new SemanticAnalyzer(TargetArchitecture.MOS6502);
		analyzer.Analyze(program);

		// assert - hex defaults should work
		Assert.False(analyzer.HasErrors);
	}

	// ========================================================================
	// Output Verification Tests - Verify actual byte output
	// ========================================================================

	[Fact]
	public void MacroDefaultParameter_Output_UsesDefaultValue() {
		var source = @"
.macro load_default value=$42
	lda #value
.endmacro

@load_default
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xa9, 0x42], code); // LDA #$42 (default)
	}

	[Fact]
	public void MacroDefaultParameter_Output_OverridesDefault() {
		var source = @"
.macro load_default value=$42
	lda #value
.endmacro

@load_default $ff
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xa9, 0xff], code); // LDA #$ff (overridden)
	}

	[Fact]
	public void MacroDefaultParameter_Output_MultipleDefaults() {
		var source = @"
.macro load_two a=$10, b=$20
	lda #a
	ldx #b
.endmacro

@load_two
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xa9, 0x10, 0xa2, 0x20], code); // LDA #$10, LDX #$20
	}

	[Fact]
	public void MacroDefaultParameter_Output_PartialOverride() {
		var source = @"
.macro load_two a=$10, b=$20
	lda #a
	ldx #b
.endmacro

@load_two $ff
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xa9, 0xff, 0xa2, 0x20], code); // LDA #$ff, LDX #$20 (default)
	}

	[Fact]
	public void MacroDefaultParameter_Output_MixedRequiredAndOptional() {
		var source = @"
.macro store_value addr, value=$00
	lda #value
	sta addr
.endmacro

@store_value $0200
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		// LDA #$00 (a9 00) + STA $0200 (8d 00 02)
		Assert.Equal([0xa9, 0x00, 0x8d, 0x00, 0x02], code);
	}

	[Fact]
	public void MacroDefaultParameter_Output_MultipleInvocations() {
		var source = @"
.macro inc_by value=$01
	clc
	adc #value
.endmacro

lda #$00
@inc_by
@inc_by $10
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		// LDA #$00 (a9 00) + CLC ADC #$01 (18 69 01) + CLC ADC #$10 (18 69 10)
		Assert.Equal([0xa9, 0x00, 0x18, 0x69, 0x01, 0x18, 0x69, 0x10], code);
	}
}
