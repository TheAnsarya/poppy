using Poppy.Core.CodeGen;
using Poppy.Core.Parser;
using Poppy.Core.Semantics;

namespace Poppy.Tests.Semantics;

/// <summary>
/// Tests for repeat blocks (.rept/.endr).
/// </summary>
public class RepeatBlockTests {
	/// <summary>
	/// Helper to compile source and return generated bytes.
	/// </summary>
	private static (byte[] Code, CodeGenerator Generator, SemanticAnalyzer Analyzer) Compile(string source) {
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		var analyzer = new SemanticAnalyzer(TargetArchitecture.MOS6502);
		analyzer.Analyze(program);

		var generator = new CodeGenerator(analyzer);
		var code = generator.Generate(program);

		return (code, generator, analyzer);
	}

	[Fact]
	public void RepeatBlock_SimpleRepeat_ParsesCorrectly() {
		// arrange
		var source = @"
.rept 3
	nop
.endr
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		// assert
		Assert.False(parser.HasErrors);
		Assert.Single(program.Statements);
		var repeat = Assert.IsType<RepeatBlockNode>(program.Statements[0]);
		Assert.Single(repeat.Body);
	}

	[Fact]
	public void RepeatBlock_ZeroCount_ParsesCorrectly() {
		// arrange
		var source = @"
.rept 0
	nop
.endr
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		// assert
		Assert.False(parser.HasErrors);
		Assert.Single(program.Statements);
		Assert.IsType<RepeatBlockNode>(program.Statements[0]);
	}

	[Fact]
	public void RepeatBlock_MultipleStatements_ParsesCorrectly() {
		// arrange
		var source = @"
.rept 2
	lda #$00
	sta $2000
	nop
.endr
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		// assert
		Assert.False(parser.HasErrors);
		Assert.Single(program.Statements);
		var repeat = Assert.IsType<RepeatBlockNode>(program.Statements[0]);
		Assert.Equal(3, repeat.Body.Count);
	}

	[Fact]
	public void RepeatBlock_NestedRepeats_ParsesCorrectly() {
		// arrange
		var source = @"
.rept 2
	.rept 3
		nop
	.endr
.endr
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		// assert
		Assert.False(parser.HasErrors);
		Assert.Single(program.Statements);
		var repeat = Assert.IsType<RepeatBlockNode>(program.Statements[0]);
		Assert.Single(repeat.Body);
		Assert.IsType<RepeatBlockNode>(repeat.Body[0]);
	}

	[Fact]
	public void RepeatBlock_ExpressionCount_ParsesCorrectly() {
		// arrange
		var source = @"
COUNT = 5
.rept COUNT * 2
	nop
.endr
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		// assert
		Assert.False(parser.HasErrors);
		Assert.Equal(2, program.Statements.Count);
		Assert.IsType<RepeatBlockNode>(program.Statements[1]);
	}

	[Fact]
	public void RepeatBlock_ExecutesCorrectNumberOfTimes() {
		// arrange
		var source = @"
.rept 3
	nop
.endr
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		var analyzer = new SemanticAnalyzer(TargetArchitecture.MOS6502);
		analyzer.Analyze(program);

		// assert - should execute without errors
		Assert.False(analyzer.HasErrors);
	}

	[Fact]
	public void RepeatBlock_MissingEndr_ReportsError() {
		// arrange
		var source = @"
.rept 3
	nop
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		// assert
		Assert.True(parser.HasErrors);
		Assert.Contains(parser.Errors, e => e.Message.Contains(".endr"));
	}

	// ========================================================================
	// Output Verification Tests - Verify actual byte output
	// ========================================================================

	[Fact]
	public void RepeatBlock_Output_ThreeNops() {
		var source = @"
.rept 3
	nop
.endr
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xea, 0xea, 0xea], code); // 3 NOPs
	}

	[Fact]
	public void RepeatBlock_Output_ZeroRepeat() {
		var source = @"
.rept 0
	nop
.endr
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Empty(code); // Zero repetitions
	}

	[Fact]
	public void RepeatBlock_Output_DataDirective() {
		var source = @"
.rept 5
	.byte $ff
.endr
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xff, 0xff, 0xff, 0xff, 0xff], code);
	}

	[Fact]
	public void RepeatBlock_Output_MultipleStatements() {
		var source = @"
.rept 2
	lda #$00
	nop
.endr
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		// 2x (LDA #$00 + NOP) = a9 00 ea a9 00 ea
		Assert.Equal([0xa9, 0x00, 0xea, 0xa9, 0x00, 0xea], code);
	}

	[Fact]
	public void RepeatBlock_Output_SymbolCount() {
		var source = @"
COUNT = 4
.rept COUNT
	inx
.endr
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xe8, 0xe8, 0xe8, 0xe8], code); // 4 INX
	}

	[Fact]
	public void RepeatBlock_Output_WithCodeBefore() {
		var source = @"
ldx #$00
.rept 3
	inx
.endr
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		// LDX #$00 (a2 00) + 3x INX (e8)
		Assert.Equal([0xa2, 0x00, 0xe8, 0xe8, 0xe8], code);
	}
}
