using Poppy.Core.CodeGen;
using Poppy.Core.Parser;
using Poppy.Core.Semantics;

namespace Poppy.Tests.Semantics;

/// <summary>
/// Tests for conditional assembly directives (.if, .else, .elseif, .endif).
/// </summary>
public class ConditionalAssemblyTests {
	/// <summary>
	/// Helper to compile source and return generated bytes.
	/// </summary>
	private static (byte[] Code, CodeGenerator Generator, SemanticAnalyzer Analyzer) Compile(string source) {
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		var analyzer = new SemanticAnalyzer(TargetArchitecture.MOS6502);
		analyzer.Analyze(program);

		var generator = new CodeGenerator(analyzer);
		var code = generator.Generate(program);

		return (code, generator, analyzer);
	}

	[Fact]
	public void ConditionalAssembly_IfTrue_ParsesSuccessfully() {
		// arrange
		var source = @"
.if 1
	nop
.endif
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		// assert - should parse without errors
		Assert.False(parser.HasErrors);
		Assert.Single(program.Statements);
		Assert.IsType<ConditionalNode>(program.Statements[0]);
	}

	[Fact]
	public void ConditionalAssembly_IfFalse_ParsesSuccessfully() {
		// arrange
		var source = @"
.if 0
	nop
.endif
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		// assert
		Assert.False(parser.HasErrors);
		Assert.Single(program.Statements);
		Assert.IsType<ConditionalNode>(program.Statements[0]);
	}

	[Fact]
	public void ConditionalAssembly_IfElse_ParsesSuccessfully() {
		// arrange
		var source = @"
.if 1
	nop
.else
	brk
.endif
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		// assert
		Assert.False(parser.HasErrors);
		Assert.Single(program.Statements);
		var conditional = Assert.IsType<ConditionalNode>(program.Statements[0]);
		Assert.NotNull(conditional.ElseBlock);
	}

	[Fact]
	public void ConditionalAssembly_IfElseIf_ParsesSuccessfully() {
		// arrange
		var source = @"
.if 0
	nop
.elseif 1
	brk
.endif
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		// assert
		Assert.False(parser.HasErrors);
		Assert.Single(program.Statements);
		var conditional = Assert.IsType<ConditionalNode>(program.Statements[0]);
		Assert.Single(conditional.ElseIfBranches);
	}

	[Fact]
	public void ConditionalAssembly_MultipleElseIf_ParsesSuccessfully() {
		// arrange
		var source = @"
.if 0
	nop
.elseif 0
	brk
.elseif 1
	clc
.else
	sec
.endif
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		// assert
		Assert.False(parser.HasErrors);
		Assert.Single(program.Statements);
		var conditional = Assert.IsType<ConditionalNode>(program.Statements[0]);
		Assert.Equal(2, conditional.ElseIfBranches.Count);
		Assert.NotNull(conditional.ElseBlock);
	}

	[Fact]
	public void ConditionalAssembly_NestedConditionals_ParsesSuccessfully() {
		// arrange
		var source = @"
.if 1
	.if 1
		nop
	.endif
.endif
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		// assert
		Assert.False(parser.HasErrors);
		Assert.Single(program.Statements);
		var conditional = Assert.IsType<ConditionalNode>(program.Statements[0]);
		Assert.Single(conditional.ThenBlock);
		Assert.IsType<ConditionalNode>(conditional.ThenBlock[0]);
	}

	[Fact]
	public void ConditionalAssembly_IfTrue_ExecutesThenBlock() {
		// arrange
		var source = @"
.if 1
	nop
.endif
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		var analyzer = new SemanticAnalyzer(TargetArchitecture.MOS6502);
		analyzer.Analyze(program);

		// assert - should analyze without errors
		Assert.False(analyzer.HasErrors);
	}

	[Fact]
	public void ConditionalAssembly_IfFalse_SkipsThenBlock() {
		// arrange
		var source = @"
.if 0
	nop
.endif
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		var analyzer = new SemanticAnalyzer(TargetArchitecture.MOS6502);
		analyzer.Analyze(program);

		// assert
		Assert.False(analyzer.HasErrors);
	}

	[Fact]
	public void ConditionalAssembly_MissingEndif_ReportsError() {
		// arrange
		var source = @"
.if 1
	nop
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		// assert - parser should report error
		Assert.True(parser.HasErrors);
		Assert.Contains(parser.Errors, e => e.Message.Contains(".endif"));
	}

	[Fact]
	public void ConditionalAssembly_MultipleElse_ReportsError() {
		// arrange
		var source = @"
.if 1
	nop
.else
	brk
.else
	clc
.endif
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		// assert - parser should report error
		Assert.True(parser.HasErrors);
		Assert.Contains(parser.Errors, e => e.Message.Contains(".else"));
	}

	[Fact]
	public void ConditionalAssembly_ElseIfAfterElse_ReportsError() {
		// arrange
		var source = @"
.if 1
	nop
.else
	brk
.elseif 1
	clc
.endif
";
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var program = parser.Parse();

		// assert - parser should report error
		Assert.True(parser.HasErrors);
		Assert.Contains(parser.Errors, e => e.Message.Contains(".elseif") && e.Message.Contains(".else"));
	}

	// ========================================================================
	// Output Verification Tests - Verify actual byte output
	// ========================================================================

	[Fact]
	public void ConditionalAssembly_Output_IfTrueExecutes() {
		var source = @"
.if 1
	lda #$42
.endif
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xa9, 0x42], code); // LDA #$42
	}

	[Fact]
	public void ConditionalAssembly_Output_IfFalseSkips() {
		var source = @"
.if 0
	lda #$42
.endif
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Empty(code); // Nothing generated
	}

	[Fact]
	public void ConditionalAssembly_Output_ElseExecutesWhenFalse() {
		var source = @"
.if 0
	lda #$00
.else
	lda #$ff
.endif
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xa9, 0xff], code); // LDA #$ff from else
	}

	[Fact]
	public void ConditionalAssembly_Output_ElseIfChain() {
		var source = @"
MODE = 2

.if MODE == 1
	lda #$01
.elseif MODE == 2
	lda #$02
.elseif MODE == 3
	lda #$03
.else
	lda #$00
.endif
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xa9, 0x02], code); // LDA #$02 (MODE=2)
	}

	[Fact]
	public void ConditionalAssembly_Output_SymbolValueConditional() {
		var source = @"
FEATURE = 0

.if FEATURE
	brk
.else
	nop
.endif
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xea], code); // NOP (FEATURE=0, so else)
	}

	[Fact]
	public void ConditionalAssembly_Output_MultipleBlocks() {
		var source = @"
A = 1
B = 0

.if A
	nop
.endif

.if B
	brk
.endif

.if A
	clc
.endif
";
		var (code, gen, analyzer) = Compile(source);

		Assert.False(analyzer.HasErrors);
		Assert.False(gen.HasErrors);
		Assert.Equal([0xea, 0x18], code); // NOP + CLC (B block skipped)
	}
}
