// ============================================================================
// NamedAnonymousLabelTests.cs - Tests for Named Anonymous Labels (+name/-name)
// Poppy Compiler - Multi-system Assembly Compiler
// ============================================================================

using Poppy.Core.CodeGen;
using Poppy.Core.Lexer;
using Poppy.Core.Parser;
using Poppy.Core.Semantics;

namespace Poppy.Tests.Semantics;

/// <summary>
/// Tests for named anonymous labels (+name/-name syntax).
/// Named anonymous labels allow for more readable forward and backward references
/// without creating globally unique label names.
/// </summary>
public class NamedAnonymousLabelTests {
	// ========================================================================
	// Helper Methods
	// ========================================================================

	/// <summary>
	/// Compiles assembly source and returns the generated bytes.
	/// </summary>
	private static byte[] Compile(string source) {
		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var ast = parser.Parse();

		var analyzer = new SemanticAnalyzer(TargetArchitecture.MOS6502);
		analyzer.Analyze(ast);

		if (analyzer.Errors.Count > 0) {
			throw new Exception($"Semantic error: {analyzer.Errors[0].Message}");
		}

		var generator = new CodeGenerator(analyzer);
		var code = generator.Generate(ast);

		if (generator.Errors.Count > 0) {
			throw new Exception($"Code generation error: {generator.Errors[0].Message}");
		}

		return code;
	}

	// ========================================================================
	// Lexer Tests
	// ========================================================================

	[Fact]
	public void Lexer_NamedAnonymousForward_ScansCorrectly() {
		var lexer = new Core.Lexer.Lexer("+loop:", "test.pasm");
		var tokens = lexer.Tokenize();

		Assert.Contains(tokens, t => t.Type == TokenType.NamedAnonymousForward && t.Text == "+loop");
	}

	[Fact]
	public void Lexer_NamedAnonymousBackward_ScansCorrectly() {
		var lexer = new Core.Lexer.Lexer("-loop", "test.pasm");
		var tokens = lexer.Tokenize();

		Assert.Contains(tokens, t => t.Type == TokenType.NamedAnonymousBackward && t.Text == "-loop");
	}

	[Fact]
	public void Lexer_NamedAnonymous_DistinctFromRegularAnonymous() {
		var lexer = new Core.Lexer.Lexer("++", "test.pasm");
		var tokens = lexer.Tokenize();

		// ++ should still be regular anonymous forward, not named
		Assert.Contains(tokens, t => t.Type == TokenType.AnonymousForward && t.Text == "++");
	}

	[Fact]
	public void Lexer_NamedAnonymous_MultipleCharNames() {
		var lexer = new Core.Lexer.Lexer("+my_long_label_name:", "test.pasm");
		var tokens = lexer.Tokenize();

		Assert.Contains(tokens, t => t.Type == TokenType.NamedAnonymousForward && t.Text == "+my_long_label_name");
	}

	[Fact]
	public void Lexer_NamedAnonymous_AlphanumericNames() {
		var lexer = new Core.Lexer.Lexer("+loop1:", "test.pasm");
		var tokens = lexer.Tokenize();

		Assert.Contains(tokens, t => t.Type == TokenType.NamedAnonymousForward && t.Text == "+loop1");
	}

	// ========================================================================
	// Parser Tests
	// ========================================================================

	[Fact]
	public void Parser_NamedAnonymousLabel_ParsesAsLabel() {
		var lexer = new Core.Lexer.Lexer("+loop:\n    nop", "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var ast = parser.Parse();

		Assert.NotEmpty(ast.Statements);
		var labelNode = ast.Statements[0] as LabelNode;
		Assert.NotNull(labelNode);
		Assert.Equal("+loop", labelNode.Name);
	}

	[Fact]
	public void Parser_NamedAnonymousReference_ParsesInExpression() {
		var source = """
			.org $8000
			+loop:
			    nop
			    jmp +loop
			""";

		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var ast = parser.Parse();

		// Should parse without errors
		Assert.Empty(parser.Errors);
	}

	// ========================================================================
	// Basic Functionality Tests
	// ========================================================================

	[Fact]
	public void NamedAnonymousLabel_ForwardReference_Resolves() {
		var source = """
			.org $8000
			    jmp +done
			    nop
			    nop
			+done:
			    rts
			""";

		// jmp +done at $8000 (3 bytes)
		// nop at $8003 (1 byte)
		// nop at $8004 (1 byte)
		// +done: at $8005
		// rts at $8005 (1 byte)
		// jmp $8005 -> 4c 05 80
		var output = Compile(source);

		Assert.Equal(new byte[] { 0x4c, 0x05, 0x80, 0xea, 0xea, 0x60 }, output);
	}

	[Fact]
	public void NamedAnonymousLabel_BackwardReference_Resolves() {
		var source = """
			.org $8000
			+loop:
			    nop
			    jmp -loop
			""";

		// nop -> ea
		// jmp $8000 -> 4c 00 80
		var output = Compile(source);

		Assert.Equal(new byte[] { 0xea, 0x4c, 0x00, 0x80 }, output);
	}

	[Fact]
	public void NamedAnonymousLabel_MultipleReferencesToSame_Resolves() {
		var source = """
			.org $8000
			+loop:
			    nop
			    beq -loop
			    bne -loop
			""";

		// nop -> ea
		// beq -loop (relative -3) -> f0 fd
		// bne -loop (relative -5) -> d0 fb
		var output = Compile(source);

		Assert.Equal(new byte[] { 0xea, 0xf0, 0xfd, 0xd0, 0xfb }, output);
	}

	[Fact]
	public void NamedAnonymousLabel_MultipleLabelsSameName_PicksNearest() {
		var source = """
			.org $8000
			+loop:
			    nop
			    bne -loop
			+loop:
			    clc
			    beq -loop
			""";

		// +loop: at $8000
		// nop at $8000 (1 byte)
		// bne -loop at $8001 (2 bytes) - branches to $8000, offset = $8000 - $8003 = -3 = 0xfd
		// +loop: at $8003
		// clc at $8003 (1 byte)
		// beq -loop at $8004 (2 bytes) - branches to $8003 (nearest), offset = $8003 - $8006 = -3 = 0xfd
		var output = Compile(source);

		Assert.Equal(new byte[] { 0xea, 0xd0, 0xfd, 0x18, 0xf0, 0xfd }, output);
	}

	[Fact]
	public void NamedAnonymousLabel_DifferentNames_IndependentlyResolved() {
		var source = """
			.org $8000
			+loop1:
			    nop
			+loop2:
			    clc
			    beq -loop1
			    bne -loop2
			""";

		// nop -> ea
		// clc -> 18
		// beq -loop1 ($8000, rel -4) -> f0 fc
		// bne -loop2 ($8001, rel -5) -> d0 fb
		var output = Compile(source);

		Assert.Equal(new byte[] { 0xea, 0x18, 0xf0, 0xfc, 0xd0, 0xfb }, output);
	}

	[Fact]
	public void NamedAnonymousLabel_ForwardThenBackward_Works() {
		var source = """
			.org $8000
			    jmp +end
			+start:
			    nop
			+end:
			    jmp -start
			""";

		// jmp $8004 -> 4c 04 80
		// nop -> ea
		// jmp $8003 -> 4c 03 80
		var output = Compile(source);

		Assert.Equal(new byte[] { 0x4c, 0x04, 0x80, 0xea, 0x4c, 0x03, 0x80 }, output);
	}

	// ========================================================================
	// Branch Instruction Tests
	// ========================================================================

	[Fact]
	public void NamedAnonymousLabel_BranchForward_CorrectOffset() {
		var source = """
			.org $8000
			    beq +skip
			    nop
			    nop
			+skip:
			    rts
			""";

		// beq +skip at $8000 (2 bytes)
		// nop at $8002 (1 byte)
		// nop at $8003 (1 byte)
		// +skip: at $8004
		// rts at $8004 (1 byte)
		// Branch offset = $8004 - $8002 = +2
		// beq +2 -> f0 02
		var output = Compile(source);

		Assert.Equal(new byte[] { 0xf0, 0x02, 0xea, 0xea, 0x60 }, output);
	}

	[Fact]
	public void NamedAnonymousLabel_BranchBackward_CorrectOffset() {
		var source = """
			.org $8000
			+retry:
			    ldx #$00
			    bne -retry
			""";

		// ldx #$00 -> a2 00
		// bne -4 -> d0 fc
		var output = Compile(source);

		Assert.Equal(new byte[] { 0xa2, 0x00, 0xd0, 0xfc }, output);
	}

	// ========================================================================
	// Edge Cases Tests
	// ========================================================================

	[Fact]
	public void NamedAnonymousLabel_UnderscorePrefix_Works() {
		var source = """
			.org $8000
			+_private:
			    nop
			    jmp -_private
			""";

		var output = Compile(source);

		Assert.Equal(new byte[] { 0xea, 0x4c, 0x00, 0x80 }, output);
	}

	[Fact]
	public void NamedAnonymousLabel_MixedWithRegularAnonymous_Works() {
		var source = """
			.org $8000
			-:
			    nop
			+named:
			    clc
			    beq -named
			    bne -
			""";

		// -: at $8000
		// nop at $8000 (1 byte)
		// +named: at $8001
		// clc at $8001 (1 byte)
		// beq -named at $8002 (2 bytes) - branches to $8001, offset = $8001 - $8004 = -3 = 0xfd
		// bne - at $8004 (2 bytes) - branches to $8000, offset = $8000 - $8006 = -6 = 0xfa
		var output = Compile(source);

		Assert.Equal(new byte[] { 0xea, 0x18, 0xf0, 0xfd, 0xd0, 0xfa }, output);
	}

	// ========================================================================
	// Error Handling Tests
	// ========================================================================

	[Fact]
	public void NamedAnonymousLabel_UndefinedForward_ReportsError() {
		var source = """
			.org $8000
			    jmp +nonexistent
			""";

		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var ast = parser.Parse();

		var analyzer = new SemanticAnalyzer(TargetArchitecture.MOS6502);
		analyzer.Analyze(ast);

		Assert.NotEmpty(analyzer.Errors);
		Assert.Contains(analyzer.Errors, e => e.Message.Contains("Cannot find named anonymous"));
	}

	[Fact]
	public void NamedAnonymousLabel_UndefinedBackward_ReportsError() {
		var source = """
			.org $8000
			    jmp -nonexistent
			""";

		var lexer = new Core.Lexer.Lexer(source, "test.pasm");
		var tokens = lexer.Tokenize();
		var parser = new Core.Parser.Parser(tokens);
		var ast = parser.Parse();

		var analyzer = new SemanticAnalyzer(TargetArchitecture.MOS6502);
		analyzer.Analyze(ast);

		Assert.NotEmpty(analyzer.Errors);
		Assert.Contains(analyzer.Errors, e => e.Message.Contains("Cannot find named anonymous"));
	}
}

