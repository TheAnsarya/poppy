// ============================================================================
// SemanticAnalyzer.cs - Semantic Analysis Phase
// Poppy Compiler - Multi-system Assembly Compiler
// ============================================================================

using Poppy.Core.Lexer;
using Poppy.Core.Parser;

namespace Poppy.Core.Semantics;

/// <summary>
/// Performs semantic analysis on the AST.
/// </summary>
/// <remarks>
/// The semantic analyzer performs two passes:
/// 1. First pass: Collect all symbol definitions and calculate addresses
/// 2. Second pass: Resolve all symbol references and validate
/// </remarks>
public sealed class SemanticAnalyzer : IAstVisitor<object?> {
	private readonly MacroExpander _macroExpander;
	private readonly List<SemanticError> _errors;
	private bool _targetSetFromSource;
	private int _pass;
	private readonly HashSet<long> _autoGeneratedAddresses = [];

	// iNES header configuration
	private int? _inesPrgSize;
	private int? _inesChrSize;
	private int? _inesMapper;
	private int? _inesSubmapper;
	private bool? _inesMirroring;       // true = vertical, false = horizontal
	private bool _inesBattery;
	private bool _inesTrainer;
	private bool _inesFourScreen;
	private int? _inesPrgRamSize;
	private int? _inesChrRamSize;
	private bool _inesPal;
	private bool _useINes2 = true;      // default to iNES 2.0

	// SNES header configuration
	private string? _snesTitle;
	private string? _snesRegion;
	private int? _snesVersion;
	private int? _snesRomSizeKb;
	private int? _snesRamSizeKb;
	private bool _snesFastRom;

	// Game Boy header configuration
	private string? _gbTitle;
	private int? _gbCgbMode;
	private bool _gbSgbEnabled;
	private int? _gbCartridgeType;
	private int? _gbRomSizeKb;
	private int? _gbRamSizeKb;
	private int? _gbRegion;
	private int? _gbVersion;

	// 65816 M/X flag tracking
	private bool _accumulatorIs16Bit = false;  // M flag: false = 8-bit, true = 16-bit
	private bool _indexIs16Bit = false;        // X flag: false = 8-bit, true = 16-bit

	/// <summary>
	/// Gets the symbol table.
	/// </summary>
	public SymbolTable SymbolTable { get; }

	/// <summary>
	/// Gets the current target architecture.
	/// </summary>
	public TargetArchitecture Target { get; private set; }

	/// <summary>
	/// Gets the SNES memory mapping (lorom, hirom, exhirom).
	/// </summary>
	public string? MemoryMapping { get; private set; }

	/// <summary>
	/// Gets the NES mapper number.
	/// </summary>
	public int? NesMapper { get; private set; }

	/// <summary>
	/// Gets whether the accumulator is in 16-bit mode (65816 M flag clear).
	/// </summary>
	public bool AccumulatorIs16Bit => _accumulatorIs16Bit;

	/// <summary>
	/// Gets whether index registers are in 16-bit mode (65816 X flag clear).
	/// </summary>
	public bool IndexIs16Bit => _indexIs16Bit;

	/// <summary>
	/// Gets the iNES header builder with all configured settings, or null if not configured.
	/// </summary>
	public CodeGen.INesHeaderBuilder? GetINesHeaderBuilder() {
		// Only create if at least one iNES directive was used
		if (_inesPrgSize == null && _inesChrSize == null && _inesMapper == null &&
			_inesSubmapper == null && _inesMirroring == null && !_inesBattery &&
			!_inesTrainer && !_inesFourScreen && !_inesPal && _inesPrgRamSize == null &&
			_inesChrRamSize == null) {
			return null;
		}

		var builder = new CodeGen.INesHeaderBuilder();

		if (_inesPrgSize != null) builder.SetPrgRomSize(_inesPrgSize.Value);
		if (_inesChrSize != null) builder.SetChrRomSize(_inesChrSize.Value);
		if (_inesMapper != null) builder.SetMapper(_inesMapper.Value);
		if (_inesSubmapper != null) builder.SetSubmapper(_inesSubmapper.Value);
		if (_inesMirroring != null) builder.SetMirroring(_inesMirroring.Value);
		if (_inesPrgRamSize != null) builder.SetPrgRamSize(_inesPrgRamSize.Value);
		if (_inesChrRamSize != null) builder.SetChrRamSize(_inesChrRamSize.Value);

		builder.SetBatteryBacked(_inesBattery);
		builder.SetTrainer(_inesTrainer);
		builder.SetFourScreen(_inesFourScreen);
		builder.SetPal(_inesPal);
		builder.SetINes2(_useINes2);

		return builder;
	}

	/// <summary>
	/// Gets the SNES header builder with all configured settings, or null if not configured.
	/// </summary>
	public CodeGen.SnesHeaderBuilder? GetSnesHeaderBuilder() {
		// Only create if at least one SNES directive was used or memory mapping is set
		if (MemoryMapping == null && _snesTitle == null && _snesRegion == null &&
			_snesVersion == null && _snesRomSizeKb == null && _snesRamSizeKb == null &&
			!_snesFastRom) {
			return null;
		}

		var builder = new CodeGen.SnesHeaderBuilder();

		// Set mapping mode from MemoryMapping directive
		if (MemoryMapping != null) {
			var mode = MemoryMapping switch {
				"lorom" => CodeGen.SnesMapMode.LoRom,
				"hirom" => CodeGen.SnesMapMode.HiRom,
				"exhirom" => CodeGen.SnesMapMode.ExHiRom,
				_ => CodeGen.SnesMapMode.LoRom
			};
			builder.SetMapMode(mode);
		}

		if (_snesTitle != null) builder.SetTitle(_snesTitle);
		if (_snesRomSizeKb != null) builder.SetRomSize(_snesRomSizeKb.Value);
		if (_snesRamSizeKb != null) builder.SetRamSize(_snesRamSizeKb.Value);
		if (_snesFastRom) builder.SetFastRom(true);

		// Set region
		if (_snesRegion != null) {
			var region = _snesRegion.ToLowerInvariant() switch {
				"japan" => CodeGen.SnesRegion.Japan,
				"usa" => CodeGen.SnesRegion.NorthAmerica,
				"europe" => CodeGen.SnesRegion.Europe,
				_ => CodeGen.SnesRegion.Japan
			};
			builder.SetRegion(region);
		}

		if (_snesVersion != null) {
			builder.SetVersion((byte)_snesVersion.Value);
		}

		return builder;
	}

	/// <summary>
	/// Gets a GB header builder if GB header directives were used.
	/// </summary>
	public CodeGen.GbHeaderBuilder? GetGbHeaderBuilder() {
		// Only create if at least one GB directive was used
		if (_gbTitle == null && _gbCgbMode == null && _gbCartridgeType == null &&
			_gbRomSizeKb == null && _gbRamSizeKb == null && _gbRegion == null &&
			_gbVersion == null && !_gbSgbEnabled) {
			return null;
		}

		var builder = new CodeGen.GbHeaderBuilder();

		if (_gbTitle != null) builder.SetTitle(_gbTitle);

		if (_gbCgbMode != null) {
			var mode = _gbCgbMode.Value switch {
				0 => CodeGen.GbCgbMode.DmgOnly,
				1 => CodeGen.GbCgbMode.CgbCompatible,
				2 => CodeGen.GbCgbMode.CgbOnly,
				_ => CodeGen.GbCgbMode.DmgOnly
			};
			builder.SetCgbMode(mode);
		}

		if (_gbSgbEnabled) builder.SetSgbEnabled(true);

		if (_gbCartridgeType != null) {
			// Map numeric type to enum
			builder.SetCartridgeType((CodeGen.GbCartridgeType)_gbCartridgeType.Value);
		}

		if (_gbRomSizeKb != null) builder.SetRomSize(_gbRomSizeKb.Value);
		if (_gbRamSizeKb != null) builder.SetRamSize(_gbRamSizeKb.Value);

		if (_gbRegion != null) {
			var region = _gbRegion.Value == 0 ? CodeGen.GbRegion.Japan : CodeGen.GbRegion.International;
			builder.SetRegion(region);
		}

		if (_gbVersion != null) {
			builder.SetVersion((byte)_gbVersion.Value);
		}

		return builder;
	}

	/// <summary>
	/// Gets all semantic errors.
	/// </summary>
	public IReadOnlyList<SemanticError> Errors => _errors.Concat(_macroExpander.Errors).ToList();

	/// <summary>
	/// Gets whether analysis encountered any errors.
	/// </summary>
	public bool HasErrors => _errors.Count > 0 || _macroExpander.HasErrors;

	/// <summary>
	/// Gets the macro table.
	/// </summary>
	public MacroTable MacroTable { get; }

	/// <summary>
	/// Gets or sets the current address counter.
	/// </summary>
	public long CurrentAddress { get; set; }

	/// <summary>
	/// Gets or sets whether to auto-generate labels for JSR/JMP targets that don't have a label.
	/// When enabled, creates labels like "sub_8100" for JSR targets and "loc_8200" for JMP targets.
	/// </summary>
	public bool AutoGenerateRoutineLabels { get; set; }

	/// <summary>
	/// Creates a new semantic analyzer.
	/// </summary>
	/// <param name="target">The target architecture.</param>
	public SemanticAnalyzer(TargetArchitecture target = TargetArchitecture.MOS6502) {
		SymbolTable = new SymbolTable();
		MacroTable = new MacroTable();
		_macroExpander = new MacroExpander(MacroTable);
		_errors = [];
		Target = target;
		CurrentAddress = 0;
		_pass = 0;
	}

	/// <summary>
	/// Analyzes a program AST.
	/// </summary>
	/// <param name="program">The program to analyze.</param>
	public void Analyze(ProgramNode program) {
		// First pass: collect definitions
		_pass = 1;
		CurrentAddress = 0;
		program.Accept(this);

		// Validate all symbols are defined
		SymbolTable.ValidateAllDefined();
		_errors.AddRange(SymbolTable.Errors);
		_errors.AddRange(MacroTable.Errors);
		_errors.AddRange(_macroExpander.Errors);

		// Second pass: resolve references
		_pass = 2;
		CurrentAddress = 0;
		program.Accept(this);

		// Collect any errors from pass 2 (e.g., anonymous label resolution)
		_errors.AddRange(SymbolTable.Errors.Skip(_errors.Count));
	}

	/// <inheritdoc />
	public object? VisitProgram(ProgramNode node) {
		foreach (var statement in node.Statements) {
			statement.Accept(this);
		}

		return null;
	}

	/// <inheritdoc />
	public object? VisitLabel(LabelNode node) {
		if (_pass == 1) {
			// Handle anonymous labels (+ or -)
			if (IsAnonymousLabelName(node.Name)) {
				bool isForward = node.Name[0] == '+';
				SymbolTable.DefineAnonymousLabel(isForward, CurrentAddress, node.Location);
			} else if (IsNamedAnonymousLabelName(node.Name)) {
				// Named anonymous labels (+name)
				SymbolTable.DefineNamedAnonymousLabel(node.Name, CurrentAddress, node.Location);
			} else {
				SymbolTable.Define(
					node.Name,
					SymbolType.Label,
					CurrentAddress,
					node.Location);
			}
		}

		return null;
	}

	/// <summary>
	/// Checks if a name represents an anonymous label (all + or all -).
	/// </summary>
	private static bool IsAnonymousLabelName(string name) {
		if (string.IsNullOrEmpty(name)) return false;
		char first = name[0];
		if (first != '+' && first != '-') return false;
		return name.All(c => c == first);
	}

	/// <summary>
	/// Checks if a name represents a named anonymous label (+name or -name).
	/// </summary>
	private static bool IsNamedAnonymousLabelName(string name) {
		if (string.IsNullOrEmpty(name) || name.Length < 2) return false;
		char first = name[0];
		if (first != '+' && first != '-') return false;
		// Must have identifier characters after the prefix
		return char.IsLetter(name[1]) || name[1] == '_';
	}

	/// <inheritdoc />
	public object? VisitInstruction(InstructionNode node) {
		// Visit operand to resolve symbols
		node.Operand?.Accept(this);

		// Auto-generate labels for JSR/JMP targets in pass 1
		if (AutoGenerateRoutineLabels && _pass == 1) {
			TryAutoGenerateLabel(node);
		}

		// Track REP/SEP instructions for M/X flag state (65816)
		if (Target == TargetArchitecture.WDC65816) {
			TrackRepSep(node);
		}

		// Calculate instruction size
		var size = GetInstructionSize(node);
		CurrentAddress += size;

		return null;
	}

	/// <summary>
	/// Tracks REP/SEP instructions to update M/X flag state.
	/// </summary>
	private void TrackRepSep(InstructionNode node) {
		var mnemonic = node.Mnemonic.ToLowerInvariant();
		if (mnemonic is not ("rep" or "sep")) return;

		// Try to evaluate the operand to get the flag bits
		if (node.Operand is null) return;
		var value = EvaluateExpression(node.Operand);
		if (!value.HasValue) return;

		var bits = (byte)value.Value;
		bool affectsM = (bits & 0x20) != 0; // Bit 5 = M flag (accumulator size)
		bool affectsX = (bits & 0x10) != 0; // Bit 4 = X flag (index size)

		if (mnemonic == "rep") {
			// REP clears bits -> 16-bit mode
			if (affectsM) _accumulatorIs16Bit = true;
			if (affectsX) _indexIs16Bit = true;
		} else { // sep
			// SEP sets bits -> 8-bit mode
			if (affectsM) _accumulatorIs16Bit = false;
			if (affectsX) _indexIs16Bit = false;
		}
	}

	/// <summary>
	/// Tries to auto-generate a label for JSR/JMP instructions targeting unlabeled addresses.
	/// </summary>
	private void TryAutoGenerateLabel(InstructionNode node) {
		var mnemonic = node.Mnemonic.ToLowerInvariant();

		// Only handle JSR and JMP instructions with absolute addressing
		if (mnemonic is not ("jsr" or "jmp") ||
			node.AddressingMode is not (AddressingMode.Absolute or AddressingMode.ZeroPage)) {
			return;
		}

		// Check if the operand is a literal number (not a symbol reference)
		if (node.Operand is not NumberLiteralNode numberNode) {
			return;
		}

		var targetAddress = numberNode.Value;

		// Don't generate duplicate labels for the same address
		if (_autoGeneratedAddresses.Contains(targetAddress)) {
			return;
		}

		// Check if there's already a label at this address
		if (HasLabelAtAddress(targetAddress)) {
			return;
		}

		// Generate the label name
		var prefix = mnemonic == "jsr" ? "sub" : "loc";
		var labelName = $"{prefix}_{targetAddress:x4}";

		// Make sure the label name doesn't conflict with an existing symbol
		if (SymbolTable.Symbols.ContainsKey(labelName)) {
			return;
		}

		// Define the auto-generated label
		SymbolTable.Define(labelName, SymbolType.Label, targetAddress, node.Location);
		_autoGeneratedAddresses.Add(targetAddress);
	}

	/// <summary>
	/// Checks if any label is defined at the specified address.
	/// </summary>
	private bool HasLabelAtAddress(long address) {
		return SymbolTable.Symbols.Values.Any(s =>
			s.Type == SymbolType.Label &&
			s.Value.HasValue &&
			s.Value.Value == address);
	}

	/// <summary>
	/// Checks if an instruction is a branch instruction (uses relative addressing).
	/// </summary>
	private static bool IsBranchInstruction(string mnemonic) {
		return mnemonic.ToLowerInvariant() switch {
			"bcc" or "bcs" or "beq" or "bmi" or "bne" or "bpl" or "bvc" or "bvs" => true,
			"bra" => true, // 65816/65C02
			_ => false
		};
	}

	/// <inheritdoc />
	public object? VisitDirective(DirectiveNode node) {
		switch (node.Name.ToLowerInvariant()) {
			case "org":
				HandleOrgDirective(node);
				break;

			case "equ":
			case "=":
				HandleEquDirective(node);
				break;

			case "byte":
			case "db":
				HandleDataDirective(node, 1);
				break;

			case "word":
			case "dw":
				HandleDataDirective(node, 2);
				break;

			case "long":
			case "dl":
			case "dd":
				HandleDataDirective(node, Target == TargetArchitecture.WDC65816 ? 3 : 4);
				break;

			case "ds":
			case "fill":
			case "res":
				HandleSpaceDirective(node);
				break;

			case "define":
				HandleDefineDirective(node);
				break;

			// Target directives
			case "target":
				HandleTargetDirective(node);
				break;

			case "nes":
				SetTarget(TargetArchitecture.MOS6502, node);
				break;

			case "snes":
				SetTarget(TargetArchitecture.WDC65816, node);
				break;

			case "gb":
			case "gameboy":
				SetTarget(TargetArchitecture.SM83, node);
				break;

			// SNES memory mapping
			case "lorom":
			case "hirom":
			case "exhirom":
				HandleMemoryMapping(node);
				break;

			// 65816 register size directives
			case "a8":
				_accumulatorIs16Bit = false;
				break;
			case "a16":
				_accumulatorIs16Bit = true;
				break;
			case "i8":
				_indexIs16Bit = false;
				break;
			case "i16":
				_indexIs16Bit = true;
				break;
			case "smart":
				// Enable automatic M/X tracking from REP/SEP
				break;

			// NES mapper
			case "mapper":
				HandleMapperDirective(node);
				break;

			// iNES header directives
			case "ines_prg":
			case "ines_chr":
			case "ines_mapper":
			case "ines_submapper":
			case "ines_mirroring":
			case "ines_battery":
			case "ines_trainer":
			case "ines_fourscreen":
			case "ines_prgram":
			case "ines_chrram":
			case "ines_pal":
			case "ines2":
				HandleINesDirective(node);
				break;

			// SNES header directives
			case "snes_title":
			case "snes_region":
			case "snes_version":
			case "snes_rom_size":
			case "snes_ram_size":
			case "snes_fastrom":
				HandleSnesDirective(node);
				break;

			// Game Boy header directives
			case "gb_title":
			case "gb_cgb":
			case "gb_sgb":
			case "gb_cartridge_type":
			case "gb_rom_size":
			case "gb_ram_size":
			case "gb_region":
			case "gb_version":
				HandleGbDirective(node);
				break;

			// Assertions and diagnostics
			case "assert":
				HandleAssertDirective(node);
				break;

			case "error":
				HandleErrorDirective(node);
				break;

			case "warning":
				HandleWarningDirective(node);
				break;

			default:
				// Visit arguments for symbol resolution
				foreach (var arg in node.Arguments) {
					arg.Accept(this);
				}

				break;
		}

		return null;
	}

	/// <inheritdoc />
	public object? VisitExpression(ExpressionNode node) {
		// Base expression - should not be called directly
		return null;
	}

	/// <inheritdoc />
	public object? VisitBinaryExpression(BinaryExpressionNode node) {
		node.Left.Accept(this);
		node.Right.Accept(this);
		return null;
	}

	/// <inheritdoc />
	public object? VisitUnaryExpression(UnaryExpressionNode node) {
		node.Operand.Accept(this);
		return null;
	}

	/// <inheritdoc />
	public object? VisitNumberLiteral(NumberLiteralNode node) {
		return node.Value;
	}

	/// <inheritdoc />
	public object? VisitStringLiteral(StringLiteralNode node) {
		return node.Value;
	}

	/// <inheritdoc />
	public object? VisitIdentifier(IdentifierNode node) {
		// Handle special identifiers
		if (node.Name == "*" || node.Name == "$") {
			return CurrentAddress;
		}

		// Handle anonymous label references (+ or -) only in pass 2
		if (IsAnonymousLabelName(node.Name)) {
			if (_pass == 2) {
				bool isForward = node.Name[0] == '+';
				int count = node.Name.Length;
				var address = SymbolTable.ResolveAnonymousLabel(isForward, count, CurrentAddress, node.Location);
				return address;
			}

			return null;
		}

		// Handle named anonymous label references (+name or -name) only in pass 2
		if (IsNamedAnonymousLabelName(node.Name)) {
			if (_pass == 2) {
				var address = SymbolTable.ResolveNamedAnonymousLabel(node.Name, CurrentAddress, node.Location);
				return address;
			}

			return null;
		}

		// Reference the symbol
		SymbolTable.Reference(node.Name, node.Location);
		return null;
	}

	/// <inheritdoc />
	public object? VisitMacroDefinition(MacroDefinitionNode node) {
		if (_pass == 1) {
			// Parameters are already MacroParameter objects (from the parser)
			var parameters = node.Parameters.ToList();

			// Store the macro body as statements
			var body = node.Body.ToList();

			// Define the macro in the macro table
			MacroTable.Define(node.Name, parameters, body, node.Location);

			// Also add to symbol table for reference tracking
			SymbolTable.Define(
				node.Name,
				SymbolType.Macro,
				null,
				node.Location);
		}

		return null;
	}

	/// <inheritdoc />
	public object? VisitMacroInvocation(MacroInvocationNode node) {
		// Reference the macro
		SymbolTable.Reference(node.Name, node.Location);

		// Visit arguments
		foreach (var arg in node.Arguments) {
			arg.Accept(this);
		}

		// Expand the macro during pass 2
		if (_pass == 2) {
			var expandedStatements = _macroExpander.Expand(node, node.Arguments);

			// Visit each expanded statement
			foreach (var statement in expandedStatements) {
				statement.Accept(this);
			}
		}

		return null;
	}

	/// <inheritdoc />
	public object? VisitConditional(ConditionalNode node) {
		// Evaluate the condition
		// For symbol conditionals (.ifdef/.ifndef), null means symbol is not defined (treat as 0)
		var conditionValue = EvaluateConditionalExpression(node.Condition);

		// Determine which block to execute
		if (conditionValue != 0) {
			// Execute the then block
			foreach (var statement in node.ThenBlock) {
				statement.Accept(this);
			}
		} else {
			// Try elseif branches
			bool executed = false;
			foreach (var (condition, block) in node.ElseIfBranches) {
				var elseIfValue = EvaluateConditionalExpression(condition);
				if (elseIfValue != 0) {
					foreach (var statement in block) {
						statement.Accept(this);
					}

					executed = true;
					break;
				}
			}

			// Execute else block if no conditions were true
			if (!executed && node.ElseBlock is not null) {
				foreach (var statement in node.ElseBlock) {
					statement.Accept(this);
				}
			}
		}

		return null;
	}

	/// <summary>
	/// Evaluates a conditional expression, treating null (undefined symbol) as 0.
	/// Used by code generator for conditional assembly.
	/// </summary>
	public long EvaluateConditionalExpression(ExpressionNode expr) {
		// Special handling for logical NOT of identifier (.ifndef)
		// This must come before the general identifier handling
		if (expr is UnaryExpressionNode { Operator: UnaryOperator.LogicalNot, Operand: IdentifierNode identifier }) {
			// For .ifndef: return 1 if NOT defined, 0 if defined
			return SymbolTable.TryGetSymbol(identifier.Name, out var symbol) && symbol is not null ? 0 : 1;
		}

		// For normal expressions (including bare identifiers), evaluate the value
		// This handles both `.if SYMBOL` (evaluates symbol's value) and `.if expr`
		return EvaluateExpression(expr) ?? 0;
	}

	/// <inheritdoc />
	public object? VisitRepeatBlock(RepeatBlockNode node) {
		// Evaluate the repeat count
		var count = EvaluateExpression(node.Count);

		if (!count.HasValue || count.Value < 0) {
			_errors.Add(new SemanticError(
				$"Invalid repeat count: {count?.ToString() ?? "null"}",
				node.Location));
			return null;
		}

		// Execute the body count times
		for (int i = 0; i < count.Value; i++) {
			foreach (var statement in node.Body) {
				statement.Accept(this);
			}
		}

		return null;
	}

	/// <inheritdoc />
	public object? VisitEnumerationBlock(EnumerationBlockNode node) {
		// Only define symbols in pass 1
		if (_pass != 1) return null;

		// Evaluate the starting value
		var currentValue = EvaluateExpression(node.StartValue);
		if (!currentValue.HasValue) {
			_errors.Add(new SemanticError(
				"Enumeration start value must be a constant expression",
				node.Location));
			return null;
		}

		// Process each member
		var value = currentValue.Value;
		foreach (var member in node.Members) {
			// If member has explicit value, use it
			if (member.Value is not null) {
				var explicitValue = EvaluateExpression(member.Value);
				if (!explicitValue.HasValue) {
					_errors.Add(new SemanticError(
						$"Enumeration member '{member.Name}' value must be a constant expression",
						node.Location));
					continue;
				}

				value = explicitValue.Value;
			}

			// Define the symbol with current value
			SymbolTable.Define(member.Name, SymbolType.Constant, value, node.Location);

			// Auto-increment based on size directive
			var incrementSize = member.SizeDirective switch {
				".db" => 1,
				".dw" => 2,
				".dl" => 3,
				_ => 1
			};
			value += incrementSize;
		}

		return null;
	}

	// ========================================================================
	// Directive Handlers
	// ========================================================================

	/// <summary>
	/// Handles .org directive to set the current address.
	/// </summary>
	private void HandleOrgDirective(DirectiveNode node) {
		if (node.Arguments.Count < 1) {
			_errors.Add(new SemanticError(
				".org directive requires an address argument",
				node.Location));
			return;
		}

		var value = EvaluateExpression(node.Arguments[0]);
		if (value.HasValue) {
			CurrentAddress = value.Value;
		}
	}

	/// <summary>
	/// Handles .equ or = directive to define a constant.
	/// </summary>
	private void HandleEquDirective(DirectiveNode node) {
		if (_pass != 1) return;

		if (node.Arguments.Count < 2) {
			_errors.Add(new SemanticError(
				".equ directive requires a name and value",
				node.Location));
			return;
		}

		if (node.Arguments[0] is not IdentifierNode nameNode) {
			_errors.Add(new SemanticError(
				".equ directive requires an identifier as the first argument",
				node.Location));
			return;
		}

		var value = EvaluateExpression(node.Arguments[1]);
		SymbolTable.Define(nameNode.Name, SymbolType.Constant, value, node.Location);
	}

	/// <summary>
	/// Handles data directives (.byte, .word, etc.).
	/// </summary>
	private void HandleDataDirective(DirectiveNode node, int bytesPerElement) {
		foreach (var arg in node.Arguments) {
			if (arg is StringLiteralNode strNode) {
				// Each character is one byte
				CurrentAddress += strNode.Value.Length;
			} else {
				arg.Accept(this);
				CurrentAddress += bytesPerElement;
			}
		}
	}

	/// <summary>
	/// Handles space/reserve directives (.ds, .fill, .res).
	/// </summary>
	private void HandleSpaceDirective(DirectiveNode node) {
		if (node.Arguments.Count < 1) {
			_errors.Add(new SemanticError(
				$".{node.Name} directive requires a count argument",
				node.Location));
			return;
		}

		var count = EvaluateExpression(node.Arguments[0]);
		if (count.HasValue) {
			CurrentAddress += count.Value;
		}
	}

	/// <summary>
	/// Handles .define directive.
	/// </summary>
	private void HandleDefineDirective(DirectiveNode node) {
		if (_pass != 1) return;

		if (node.Arguments.Count < 1) {
			_errors.Add(new SemanticError(
				".define directive requires at least a name",
				node.Location));
			return;
		}

		if (node.Arguments[0] is not IdentifierNode nameNode) {
			_errors.Add(new SemanticError(
				".define directive requires an identifier",
				node.Location));
			return;
		}

		long? value = null;
		if (node.Arguments.Count >= 2) {
			value = EvaluateExpression(node.Arguments[1]);
		}

		SymbolTable.Define(nameNode.Name, SymbolType.Constant, value ?? 1, node.Location);
	}

	/// <summary>
	/// Handles .target directive with architecture argument.
	/// </summary>
	private void HandleTargetDirective(DirectiveNode node) {
		if (_pass != 1) return;

		if (node.Arguments.Count < 1) {
			_errors.Add(new SemanticError(
				".target directive requires an architecture (nes, snes, gb, atari2600, lynx, genesis, sms, ws, gba, spc700, tg16)",
				node.Location));
			return;
		}

		if (node.Arguments[0] is not IdentifierNode targetNode) {
			_errors.Add(new SemanticError(
				".target directive requires an identifier",
				node.Location));
			return;
		}

		var targetName = targetNode.Name.ToLowerInvariant();
		var target = targetName switch {
			"nes" or "6502" => TargetArchitecture.MOS6502,
			"atari2600" or "2600" or "6507" => TargetArchitecture.MOS6507,
			"atarilynx" or "lynx" or "65sc02" => TargetArchitecture.MOS65SC02,
			"snes" or "65816" => TargetArchitecture.WDC65816,
			"gb" or "gameboy" or "sm83" => TargetArchitecture.SM83,
			"genesis" or "megadrive" or "md" or "68000" or "m68k" => TargetArchitecture.M68000,
			"sms" or "mastersystem" or "z80" => TargetArchitecture.Z80,
			"wonderswan" or "ws" or "wsc" or "v30mz" => TargetArchitecture.V30MZ,
			"gba" or "gameboyadvance" or "arm" or "arm7tdmi" => TargetArchitecture.ARM7TDMI,
			"spc700" => TargetArchitecture.SPC700,
			"tg16" or "turbografx16" or "pcengine" or "huc6280" => TargetArchitecture.HuC6280,
			_ => (TargetArchitecture?)null
		};

		if (target is null) {
			_errors.Add(new SemanticError(
				$"Unknown target architecture: {targetNode.Name}",
				node.Location));
			return;
		}

		SetTarget(target.Value, node);
	}

	/// <summary>
	/// Sets the target architecture.
	/// </summary>
	private void SetTarget(TargetArchitecture target, DirectiveNode node) {
		// Allow setting to the same value (idempotent)
		if (_targetSetFromSource && Target != target) {
			_errors.Add(new SemanticError(
				"Target architecture already set - cannot change",
				node.Location));
			return;
		}

		Target = target;
		_targetSetFromSource = true;
	}

	/// <summary>
	/// Handles SNES memory mapping directives (.lorom, .hirom, .exhirom).
	/// </summary>
	private void HandleMemoryMapping(DirectiveNode node) {
		if (_pass != 1) return;

		if (MemoryMapping is not null) {
			_errors.Add(new SemanticError(
				"Memory mapping already set - cannot change",
				node.Location));
			return;
		}

		MemoryMapping = node.Name.ToLowerInvariant();

		// Ensure target is SNES
		if (Target != TargetArchitecture.WDC65816) {
			_errors.Add(new SemanticError(
				$".{node.Name} directive is only valid for SNES/65816 target",
				node.Location));
		}
	}

	/// <summary>
	/// Handles .mapper directive for NES mapper selection.
	/// </summary>
	private void HandleMapperDirective(DirectiveNode node) {
		if (_pass != 1) return;

		if (node.Arguments.Count < 1) {
			_errors.Add(new SemanticError(
				".mapper directive requires a mapper number",
				node.Location));
			return;
		}

		var mapperValue = EvaluateExpression(node.Arguments[0]);
		if (mapperValue is null) {
			_errors.Add(new SemanticError(
				".mapper directive requires a constant mapper number",
				node.Location));
			return;
		}

		if (NesMapper is not null) {
			_errors.Add(new SemanticError(
				"Mapper already set - cannot change",
				node.Location));
			return;
		}

		NesMapper = (int)mapperValue;

		// Ensure target is NES
		if (Target != TargetArchitecture.MOS6502) {
			_errors.Add(new SemanticError(
				".mapper directive is only valid for NES/6502 target",
				node.Location));
		}
	}

	/// <summary>
	/// Handles iNES header directives (.ines_prg, .ines_chr, etc.).
	/// </summary>
	private void HandleINesDirective(DirectiveNode node) {
		if (_pass != 1) return;

		var directiveName = node.Name.ToLowerInvariant();

		// Get the value from first argument (if required)
		long? value = null;
		if (node.Arguments.Count > 0) {
			value = EvaluateExpression(node.Arguments[0]);
			if (value is null) {
				_errors.Add(new SemanticError(
					$".{directiveName} directive requires a constant value",
					node.Location));
				return;
			}
		}

		switch (directiveName) {
			case "ines_prg":
				if (value is null) {
					_errors.Add(new SemanticError(
						".ines_prg directive requires a PRG ROM size (in 16KB units)",
						node.Location));
					return;
				}

				_inesPrgSize = (int)value;
				break;

			case "ines_chr":
				if (value is null) {
					_errors.Add(new SemanticError(
						".ines_chr directive requires a CHR ROM size (in 8KB units)",
						node.Location));
					return;
				}

				_inesChrSize = (int)value;
				break;

			case "ines_mapper":
				if (value is null) {
					_errors.Add(new SemanticError(
						".ines_mapper directive requires a mapper number",
						node.Location));
					return;
				}

				_inesMapper = (int)value;
				break;

			case "ines_submapper":
				if (value is null) {
					_errors.Add(new SemanticError(
						".ines_submapper directive requires a submapper number",
						node.Location));
					return;
				}

				_inesSubmapper = (int)value;
				break;

			case "ines_mirroring":
				if (value is null) {
					_errors.Add(new SemanticError(
						".ines_mirroring directive requires a mirroring mode (0=horizontal, 1=vertical)",
						node.Location));
					return;
				}

				_inesMirroring = value != 0;    // 0 = horizontal, 1 = vertical
				break;

			case "ines_battery":
				_inesBattery = value is null || value != 0;
				break;

			case "ines_trainer":
				_inesTrainer = value is null || value != 0;
				break;

			case "ines_fourscreen":
				_inesFourScreen = value is null || value != 0;
				break;

			case "ines_prgram":
				if (value is null) {
					_errors.Add(new SemanticError(
						".ines_prgram directive requires a PRG RAM size (in 8KB units)",
						node.Location));
					return;
				}

				_inesPrgRamSize = (int)value;
				break;

			case "ines_chrram":
				if (value is null) {
					_errors.Add(new SemanticError(
						".ines_chrram directive requires a CHR RAM size (in 8KB units)",
						node.Location));
					return;
				}

				_inesChrRamSize = (int)value;
				break;

			case "ines_pal":
				_inesPal = value is null || value != 0;
				break;

			case "ines2":
				_useINes2 = value is null || value != 0;
				break;
		}

		// Ensure target is NES
		if (Target != TargetArchitecture.MOS6502) {
			_errors.Add(new SemanticError(
				$".{directiveName} directive is only valid for NES/6502 target",
				node.Location));
		}
	}

	/// <summary>
	/// Handles SNES header directives (.snes_title, .snes_region, etc.).
	/// </summary>
	private void HandleSnesDirective(DirectiveNode node) {
		if (_pass != 1) return;

		var directiveName = node.Name.ToLowerInvariant();

		// Get the value from the first argument (if any)
		long? value = null;
		string? stringValue = null;

		if (node.Arguments.Count > 0) {
			// Try to get as a string first (for title and region)
			if (node.Arguments[0] is Parser.StringLiteralNode stringLit) {
				stringValue = stringLit.Value;
			} else {
				// Otherwise evaluate as numeric expression
				value = EvaluateExpression(node.Arguments[0]);
				if (value is null) {
					_errors.Add(new SemanticError(
						$".{directiveName} directive requires a constant value",
						node.Location));
					return;
				}
			}
		}

		switch (directiveName) {
			case "snes_title":
				if (stringValue is null) {
					_errors.Add(new SemanticError(
						".snes_title directive requires a string value (up to 21 characters)",
						node.Location));
					return;
				}

				if (stringValue.Length > 21) {
					_errors.Add(new SemanticError(
						$".snes_title is too long ({stringValue.Length} characters, maximum is 21)",
						node.Location));
					return;
				}

				_snesTitle = stringValue;
				break;

			case "snes_region":
				if (stringValue is null) {
					_errors.Add(new SemanticError(
						".snes_region directive requires a region string (e.g., \"Japan\", \"USA\", \"Europe\")",
						node.Location));
					return;
				}

				// Validate region string
				var validRegions = new[] { "Japan", "USA", "Europe", "Scandinavia", "France",
					"Netherlands", "Spain", "Germany", "Italy", "China", "Korea", "Canada", "Brazil", "Australia" };
				if (!validRegions.Contains(stringValue, StringComparer.OrdinalIgnoreCase)) {
					_errors.Add(new SemanticError(
						$".snes_region \"{stringValue}\" is not valid. Valid regions: {string.Join(", ", validRegions)}",
						node.Location));
					return;
				}

				_snesRegion = stringValue;
				break;

			case "snes_version":
				if (value is null) {
					_errors.Add(new SemanticError(
						".snes_version directive requires a version number (0-255)",
						node.Location));
					return;
				}

				if (value < 0 || value > 255) {
					_errors.Add(new SemanticError(
						$".snes_version must be 0-255 (got {value})",
						node.Location));
					return;
				}

				_snesVersion = (int)value;
				break;

			case "snes_rom_size":
				if (value is null) {
					_errors.Add(new SemanticError(
						".snes_rom_size directive requires a ROM size in KB (power of 2, e.g., 256, 512, 1024)",
						node.Location));
					return;
				}

				// Validate it's a power of 2
				if (value <= 0 || (value & (value - 1)) != 0) {
					_errors.Add(new SemanticError(
						$".snes_rom_size must be a power of 2 (got {value})",
						node.Location));
					return;
				}

				_snesRomSizeKb = (int)value;
				break;

			case "snes_ram_size":
				if (value is null) {
					_errors.Add(new SemanticError(
						".snes_ram_size directive requires a RAM size in KB (0, 2, 8, or 32)",
						node.Location));
					return;
				}

				// Validate it's a valid SNES RAM size
				var validRamSizes = new[] { 0, 2, 8, 32 };
				if (!validRamSizes.Contains((int)value)) {
					_errors.Add(new SemanticError(
						$".snes_ram_size must be 0, 2, 8, or 32 KB (got {value})",
						node.Location));
					return;
				}

				_snesRamSizeKb = (int)value;
				break;

			case "snes_fastrom":
				_snesFastRom = value is null || value != 0;
				break;
		}

		// Ensure target is SNES/65816
		if (Target != TargetArchitecture.WDC65816) {
			_errors.Add(new SemanticError(
				$".{directiveName} directive is only valid for SNES/65816 target",
				node.Location));
		}
	}

	/// <summary>
	/// Handles Game Boy header directives (.gb_title, .gb_cgb, etc.).
	/// </summary>
	private void HandleGbDirective(DirectiveNode node) {
		if (_pass != 1) return;

		var directiveName = node.Name.ToLowerInvariant();

		// Get the value from the first argument (if any)
		long? value = null;
		string? stringValue = null;

		if (node.Arguments.Count > 0) {
			// Try to get as a string first (for title)
			if (node.Arguments[0] is Parser.StringLiteralNode stringLit) {
				stringValue = stringLit.Value;
			} else {
				// Otherwise evaluate as numeric expression
				value = EvaluateExpression(node.Arguments[0]);
				if (value is null) {
					_errors.Add(new SemanticError(
						$".{directiveName} directive requires a constant value",
						node.Location));
					return;
				}
			}
		}

		switch (directiveName) {
			case "gb_title":
				if (stringValue is null) {
					_errors.Add(new SemanticError(
						".gb_title directive requires a string value (max 16 characters)",
						node.Location));
					return;
				}

				if (stringValue.Length > 16) {
					_errors.Add(new SemanticError(
						$".gb_title is too long ({stringValue.Length} characters, maximum is 16)",
						node.Location));
					return;
				}

				_gbTitle = stringValue;
				break;

			case "gb_cgb":
				if (value is null) {
					_errors.Add(new SemanticError(
						".gb_cgb directive requires a mode (0=DMG only, 1=CGB compatible, 2=CGB only)",
						node.Location));
					return;
				}

				if (value < 0 || value > 2) {
					_errors.Add(new SemanticError(
						$".gb_cgb mode must be 0, 1, or 2 (got {value})",
						node.Location));
					return;
				}

				_gbCgbMode = (int)value;
				break;

			case "gb_sgb":
				_gbSgbEnabled = value is null || value != 0;
				break;

			case "gb_cartridge_type":
				if (value is null) {
					_errors.Add(new SemanticError(
						".gb_cartridge_type directive requires a cartridge type code",
						node.Location));
					return;
				}

				if (value < 0 || value > 0x1e) {
					_errors.Add(new SemanticError(
						$".gb_cartridge_type must be 0-$1e (got ${value:x})",
						node.Location));
					return;
				}

				_gbCartridgeType = (int)value;
				break;

			case "gb_rom_size":
				if (value is null) {
					_errors.Add(new SemanticError(
						".gb_rom_size directive requires a ROM size in KB (32, 64, 128, 256, etc.)",
						node.Location));
					return;
				}

				// Validate it's a power of 2 >= 32
				if (value < 32 || (value & (value - 1)) != 0) {
					_errors.Add(new SemanticError(
						$".gb_rom_size must be a power of 2 >= 32 (got {value})",
						node.Location));
					return;
				}

				_gbRomSizeKb = (int)value;
				break;

			case "gb_ram_size":
				if (value is null) {
					_errors.Add(new SemanticError(
						".gb_ram_size directive requires a RAM size in KB (0, 2, 8, 32, 64, or 128)",
						node.Location));
					return;
				}

				// Validate it's a valid GB RAM size
				var validRamSizes = new[] { 0, 2, 8, 32, 64, 128 };
				if (!validRamSizes.Contains((int)value)) {
					_errors.Add(new SemanticError(
						$".gb_ram_size must be 0, 2, 8, 32, 64, or 128 KB (got {value})",
						node.Location));
					return;
				}

				_gbRamSizeKb = (int)value;
				break;

			case "gb_region":
				if (value is null) {
					_errors.Add(new SemanticError(
						".gb_region directive requires a region code (0=Japan, 1=International)",
						node.Location));
					return;
				}

				if (value < 0 || value > 1) {
					_errors.Add(new SemanticError(
						$".gb_region must be 0 or 1 (got {value})",
						node.Location));
					return;
				}

				_gbRegion = (int)value;
				break;

			case "gb_version":
				if (value is null) {
					_errors.Add(new SemanticError(
						".gb_version directive requires a version number (0-255)",
						node.Location));
					return;
				}

				if (value < 0 || value > 255) {
					_errors.Add(new SemanticError(
						$".gb_version must be 0-255 (got {value})",
						node.Location));
					return;
				}

				_gbVersion = (int)value;
				break;
		}

		// Ensure target is Game Boy
		if (Target != TargetArchitecture.SM83) {
			_errors.Add(new SemanticError(
				$".{directiveName} directive is only valid for Game Boy/SM83 target",
				node.Location));
		}
	}

	/// <summary>
	/// Handles .assert directive for compile-time assertions.
	/// </summary>
	private void HandleAssertDirective(DirectiveNode node) {
		// Assertions are checked in pass 2 after all symbols are defined
		if (_pass != 2) return;

		if (node.Arguments.Count < 1) {
			_errors.Add(new SemanticError(
				".assert directive requires a condition expression",
				node.Location));
			return;
		}

		// Evaluate the assertion condition
		var condition = EvaluateExpression(node.Arguments[0]);
		if (condition is null) {
			_errors.Add(new SemanticError(
				".assert condition could not be evaluated",
				node.Location));
			return;
		}

		// Check if assertion passes
		if (condition == 0) {
			// Get optional message
			string message = "Assertion failed";
			if (node.Arguments.Count >= 2 && node.Arguments[1] is StringLiteralNode strNode) {
				message = strNode.Value;
			}

			_errors.Add(new SemanticError(message, node.Location));
		}
	}

	/// <summary>
	/// Handles .error directive for unconditional errors.
	/// </summary>
	private void HandleErrorDirective(DirectiveNode node) {
		if (_pass != 1) return;

		string message = "Error directive";
		if (node.Arguments.Count >= 1 && node.Arguments[0] is StringLiteralNode strNode) {
			message = strNode.Value;
		}

		_errors.Add(new SemanticError(message, node.Location));
	}

	/// <summary>
	/// Handles .warning directive for unconditional warnings.
	/// </summary>
	private void HandleWarningDirective(DirectiveNode node) {
		if (_pass != 1) return;

		string message = "Warning";
		if (node.Arguments.Count >= 1 && node.Arguments[0] is StringLiteralNode strNode) {
			message = strNode.Value;
		}

		// For now, treat warnings as errors (could add separate warning list later)
		_errors.Add(new SemanticError($"Warning: {message}", node.Location));
	}

	// ========================================================================
	// Expression Evaluation
	// ========================================================================

	/// <summary>
	/// Attempts to evaluate an expression to a constant value.
	/// </summary>
	/// <param name="expr">The expression to evaluate.</param>
	/// <returns>The value, or null if not evaluable.</returns>
	public long? EvaluateExpression(ExpressionNode expr) {
		return expr switch {
			NumberLiteralNode num => num.Value,
			IdentifierNode id => EvaluateIdentifier(id),
			BinaryExpressionNode bin => EvaluateBinary(bin),
			UnaryExpressionNode un => EvaluateUnary(un),
			_ => null
		};
	}

	/// <summary>
	/// Evaluates an identifier reference.
	/// </summary>
	private long? EvaluateIdentifier(IdentifierNode node) {
		// Special identifiers
		if (node.Name == "*" || node.Name == "$") {
			return CurrentAddress;
		}

		// Anonymous label references (+ or -)
		if (IsAnonymousLabelName(node.Name)) {
			bool isForward = node.Name[0] == '+';
			int count = node.Name.Length;
			return SymbolTable.ResolveAnonymousLabel(isForward, count, CurrentAddress, node.Location);
		}

		// Named anonymous label references (+name or -name)
		if (IsNamedAnonymousLabelName(node.Name)) {
			return SymbolTable.ResolveNamedAnonymousLabel(node.Name, CurrentAddress, node.Location);
		}

		if (SymbolTable.TryGetSymbol(node.Name, out var symbol) && symbol?.Value.HasValue == true) {
			return symbol.Value;
		}

		return null;
	}

	/// <summary>
	/// Evaluates a binary expression.
	/// </summary>
	private long? EvaluateBinary(BinaryExpressionNode node) {
		var left = EvaluateExpression(node.Left);
		var right = EvaluateExpression(node.Right);

		if (!left.HasValue || !right.HasValue) {
			return null;
		}

		return node.Operator switch {
			BinaryOperator.Add => left.Value + right.Value,
			BinaryOperator.Subtract => left.Value - right.Value,
			BinaryOperator.Multiply => left.Value * right.Value,
			BinaryOperator.Divide => right.Value != 0 ? left.Value / right.Value : null,
			BinaryOperator.Modulo => right.Value != 0 ? left.Value % right.Value : null,
			BinaryOperator.BitwiseAnd => left.Value & right.Value,
			BinaryOperator.BitwiseOr => left.Value | right.Value,
			BinaryOperator.BitwiseXor => left.Value ^ right.Value,
			BinaryOperator.LeftShift => left.Value << (int)right.Value,
			BinaryOperator.RightShift => left.Value >> (int)right.Value,
			BinaryOperator.Equal => left.Value == right.Value ? 1 : 0,
			BinaryOperator.NotEqual => left.Value != right.Value ? 1 : 0,
			BinaryOperator.LessThan => left.Value < right.Value ? 1 : 0,
			BinaryOperator.GreaterThan => left.Value > right.Value ? 1 : 0,
			BinaryOperator.LessOrEqual => left.Value <= right.Value ? 1 : 0,
			BinaryOperator.GreaterOrEqual => left.Value >= right.Value ? 1 : 0,
			BinaryOperator.LogicalAnd => (left.Value != 0 && right.Value != 0) ? 1 : 0,
			BinaryOperator.LogicalOr => (left.Value != 0 || right.Value != 0) ? 1 : 0,
			_ => null
		};
	}

	/// <summary>
	/// Evaluates a unary expression.
	/// </summary>
	private long? EvaluateUnary(UnaryExpressionNode node) {
		var operand = EvaluateExpression(node.Operand);

		if (!operand.HasValue) {
			return null;
		}

		return node.Operator switch {
			UnaryOperator.Negate => -operand.Value,
			UnaryOperator.BitwiseNot => ~operand.Value,
			UnaryOperator.LogicalNot => operand.Value == 0 ? 1 : 0,
			UnaryOperator.LowByte => operand.Value & 0xff,
			UnaryOperator.HighByte => (operand.Value >> 8) & 0xff,
			UnaryOperator.BankByte => (operand.Value >> 16) & 0xff,
			_ => null
		};
	}

	// ========================================================================
	// Instruction Size Calculation
	// ========================================================================

	/// <summary>
	/// Calculates the size of an instruction in bytes.
	/// </summary>
	private int GetInstructionSize(InstructionNode node) {
		// Branch instructions are always 2 bytes (opcode + relative offset)
		var mnemonic = node.Mnemonic;
		if (mnemonic.Length > 2 && mnemonic[^2] == '.') {
			mnemonic = mnemonic[..^2];
		}

		if (IsBranchInstruction(mnemonic)) {
			return 2; // opcode + 1 byte relative offset
		}

		// Base opcode is 1 byte
		int size = 1;

		// Add operand size based on addressing mode
		size += GetOperandSize(node.AddressingMode, node.SizeSuffix, mnemonic);

		return size;
	}

	/// <summary>
	/// Gets the operand size for an addressing mode.
	/// </summary>
	private int GetOperandSize(AddressingMode mode, char? sizeSuffix, string? mnemonic = null) {
		// Size suffix overrides
		if (sizeSuffix.HasValue) {
			return sizeSuffix.Value switch {
				'b' => 1,
				'w' => 2,
				'l' => 3,
				_ => 0
			};
		}

		// For 65816 immediate mode, size depends on M/X flags and instruction
		if (Target == TargetArchitecture.WDC65816 && mode == AddressingMode.Immediate && mnemonic != null) {
			var lower = mnemonic.ToLowerInvariant();
			// Index register instructions use X flag
			if (lower is "ldx" or "ldy" or "cpx" or "cpy") {
				return _indexIs16Bit ? 2 : 1; // 2 bytes in 16-bit, 1 byte in 8-bit
			}
			// Accumulator instructions use M flag
			if (lower is "lda" or "adc" or "sbc" or "cmp" or "and" or "ora" or "eor" or "bit") {
				return _accumulatorIs16Bit ? 2 : 1; // 2 bytes in 16-bit, 1 byte in 8-bit
			}
			// REP/SEP are always 8-bit immediate
			if (lower is "rep" or "sep") {
				return 1;
			}
			// PEA is always 16-bit
			if (lower is "pea") {
				return 2;
			}
			// Default to current accumulator size for other immediate instructions
			return _accumulatorIs16Bit ? 2 : 1;
		}

		return mode switch {
			AddressingMode.Implied => 0,
			AddressingMode.Accumulator => 0,
			AddressingMode.Immediate => 1, // 6502/SM83: always 1 byte immediate
			AddressingMode.ZeroPage => 1,
			AddressingMode.ZeroPageX => 1,
			AddressingMode.ZeroPageY => 1,
			AddressingMode.Absolute => 2,
			AddressingMode.AbsoluteX => 2,
			AddressingMode.AbsoluteY => 2,
			AddressingMode.Indirect => 2,
			AddressingMode.IndexedIndirect => 1,
			AddressingMode.IndirectIndexed => 1,
			AddressingMode.Relative => 1,
			AddressingMode.AbsoluteLong => 3,
			AddressingMode.AbsoluteLongX => 3,
			AddressingMode.StackRelative => 1,
			AddressingMode.StackRelativeIndirectIndexed => 1,
			AddressingMode.DirectPageIndirectLong => 1,
			AddressingMode.DirectPageIndirectLongY => 1,
			AddressingMode.AbsoluteIndirectLong => 2,
			AddressingMode.AbsoluteIndexedIndirect => 2,
			AddressingMode.BlockMove => 2,
			AddressingMode.MemoryReference => 0, // GB-specific, varies
			_ => 0
		};
	}
}

/// <summary>
/// Target CPU architecture for the assembler.
/// </summary>
public enum TargetArchitecture {
	/// <summary>MOS 6502 (NES, Commodore 64, etc.)</summary>
	MOS6502,

	/// <summary>MOS 6507 (Atari 2600 - 6502 variant with 13-bit addressing)</summary>
	MOS6507,

	/// <summary>MOS 65SC02 (Atari Lynx - 65C02 without decimal mode)</summary>
	MOS65SC02,

	/// <summary>WDC 65816 (SNES)</summary>
	WDC65816,

	/// <summary>Sharp SM83 (Game Boy)</summary>
	SM83,

	/// <summary>Motorola 68000 (Sega Genesis/Mega Drive)</summary>
	M68000,

	/// <summary>Zilog Z80 (Sega Master System, Game Gear)</summary>
	Z80,

	/// <summary>NEC V30MZ (WonderSwan, WonderSwan Color - 80186 compatible)</summary>
	V30MZ,

	/// <summary>ARM7TDMI (Game Boy Advance)</summary>
	ARM7TDMI,

	/// <summary>Sony SPC700 (SNES Audio Processor)</summary>
	SPC700,

	/// <summary>Hudson HuC6280 (TurboGrafx-16/PC Engine - 65C02 variant)</summary>
	HuC6280,
}

