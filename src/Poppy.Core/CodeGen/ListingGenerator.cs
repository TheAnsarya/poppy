// ============================================================================
// ListingGenerator.cs - Assembly Listing File Generation
// Poppy Compiler - Multi-system Assembly Compiler
// ============================================================================

using System.Text;
using Poppy.Core.Lexer;
using Poppy.Core.Semantics;

namespace Poppy.Core.CodeGen;

/// <summary>
/// Generates listing files showing assembled code with addresses, bytes, and source.
/// </summary>
public sealed class ListingGenerator {
	private readonly List<ListingEntry> _entries = [];
	private readonly Dictionary<string, string[]> _sourceCache = new();

	/// <summary>
	/// Gets all listing entries.
	/// </summary>
	public IReadOnlyList<ListingEntry> Entries => _entries;

	/// <summary>
	/// Registers source code for a file.
	/// </summary>
	/// <param name="filePath">The file path.</param>
	/// <param name="source">The source code.</param>
	public void RegisterSource(string filePath, string source) {
		if (string.IsNullOrEmpty(filePath))
			return;

		var lines = source.Split('\n');
		for (int i = 0; i < lines.Length; i++) {
			lines[i] = lines[i].TrimEnd('\r');
		}
		_sourceCache[filePath] = lines;
	}

	/// <summary>
	/// Adds a listing entry for generated code.
	/// </summary>
	/// <param name="address">The address where code was generated.</param>
	/// <param name="bytes">The generated bytes.</param>
	/// <param name="location">The source location.</param>
	public void AddEntry(long address, byte[] bytes, SourceLocation location) {
		var sourceLine = GetSourceLine(location);
		_entries.Add(new ListingEntry(address, bytes, location, sourceLine));
	}

	/// <summary>
	/// Adds a label entry (no bytes generated).
	/// </summary>
	/// <param name="address">The address of the label.</param>
	/// <param name="location">The source location.</param>
	public void AddLabelEntry(long address, SourceLocation location) {
		var sourceLine = GetSourceLine(location);
		_entries.Add(new ListingEntry(address, [], location, sourceLine));
	}

	/// <summary>
	/// Adds an origin directive entry.
	/// </summary>
	/// <param name="address">The new address.</param>
	/// <param name="location">The source location.</param>
	public void AddOrgEntry(long address, SourceLocation location) {
		var sourceLine = GetSourceLine(location);
		_entries.Add(new ListingEntry(address, [], location, sourceLine, isOrg: true));
	}

	/// <summary>
	/// Gets the source line for a location.
	/// </summary>
	private string? GetSourceLine(SourceLocation location) {
		if (!_sourceCache.TryGetValue(location.FilePath, out var lines))
			return null;

		var lineIndex = location.Line - 1;
		if (lineIndex >= 0 && lineIndex < lines.Length)
			return lines[lineIndex];

		return null;
	}

	/// <summary>
	/// Generates a listing file string.
	/// </summary>
	/// <param name="symbolTable">The symbol table for the symbol listing section.</param>
	/// <returns>The formatted listing file content.</returns>
	public string Generate(SymbolTable? symbolTable = null) {
		var sb = new StringBuilder();

		// Header
		sb.AppendLine("; Poppy Assembler Listing");
		sb.AppendLine($"; Generated: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
		sb.AppendLine();

		// Column headers
		sb.AppendLine("; Addr    Bytes                    Source");
		sb.AppendLine("; ------  -----------------------  ----------------------------------------");

		// Process entries by file
		string? currentFile = null;
		foreach (var entry in _entries.OrderBy(e => e.Location.FilePath).ThenBy(e => e.Location.Line)) {
			// File header
			if (entry.Location.FilePath != currentFile) {
				currentFile = entry.Location.FilePath;
				sb.AppendLine();
				sb.AppendLine($"; === File: {Path.GetFileName(currentFile)} ===");
				sb.AppendLine();
			}

			sb.AppendLine(FormatEntry(entry));
		}

		// Symbol table
		if (symbolTable is not null) {
			sb.AppendLine();
			sb.AppendLine();
			sb.AppendLine("; === Symbol Table ===");
			sb.AppendLine();
			sb.AppendLine("; Name                          Value    Type     Location");
			sb.AppendLine("; ----------------------------  -------  -------  ----------------------");

			foreach (var symbol in symbolTable.Symbols.Values.OrderBy(s => s.Name)) {
				var typeName = symbol.Type switch {
					SymbolType.Label => "Label",
					SymbolType.Constant => "Const",
					SymbolType.Macro => "Macro",
					SymbolType.External => "Extern",
					_ => "Unknown"
				};
				var valueStr = symbol.Value.HasValue ? $"${symbol.Value.Value:x4}" : "?";
				var location = symbol.DefinitionLocation.HasValue
					? $"{Path.GetFileName(symbol.DefinitionLocation.Value.FilePath)}:{symbol.DefinitionLocation.Value.Line}"
					: "";

				sb.AppendLine($"; {symbol.Name,-29} {valueStr,-8} {typeName,-8} {location}");
			}
		}

		// Footer
		sb.AppendLine();
		sb.AppendLine("; === End of Listing ===");

		return sb.ToString();
	}

	/// <summary>
	/// Formats a single listing entry.
	/// </summary>
	private static string FormatEntry(ListingEntry entry) {
		var sb = new StringBuilder();

		// Address column (6 chars)
		if (entry.IsOrg) {
			sb.Append($"  ${entry.Address:x4}  ");
		} else if (entry.Bytes.Length == 0) {
			// Label or comment-only line
			sb.Append("        ");
		} else {
			sb.Append($"  ${entry.Address:x4}  ");
		}

		// Bytes column (up to 8 bytes shown, 24 chars total)
		var bytesStr = string.Join(" ", entry.Bytes.Take(8).Select(b => $"{b:x2}"));
		if (entry.Bytes.Length > 8) {
			bytesStr += "...";
		}
		sb.Append($"{bytesStr,-24} ");

		// Source column
		if (entry.SourceLine is not null) {
			sb.Append(entry.SourceLine);
		}

		return sb.ToString().TrimEnd();
	}

	/// <summary>
	/// Generates a listing and writes it to a file.
	/// </summary>
	/// <param name="filePath">The output file path.</param>
	/// <param name="symbolTable">Optional symbol table to include.</param>
	public void WriteToFile(string filePath, SymbolTable? symbolTable = null) {
		var listing = Generate(symbolTable);
		File.WriteAllText(filePath, listing, Encoding.UTF8);
	}
}

/// <summary>
/// Represents a single entry in the listing file.
/// </summary>
public sealed class ListingEntry {
	/// <summary>
	/// The address of this entry.
	/// </summary>
	public long Address { get; }

	/// <summary>
	/// The generated bytes.
	/// </summary>
	public byte[] Bytes { get; }

	/// <summary>
	/// The source location.
	/// </summary>
	public SourceLocation Location { get; }

	/// <summary>
	/// The original source line text.
	/// </summary>
	public string? SourceLine { get; }

	/// <summary>
	/// Whether this is an origin directive entry.
	/// </summary>
	public bool IsOrg { get; }

	/// <summary>
	/// Creates a new listing entry.
	/// </summary>
	public ListingEntry(long address, byte[] bytes, SourceLocation location, string? sourceLine, bool isOrg = false) {
		Address = address;
		Bytes = bytes;
		Location = location;
		SourceLine = sourceLine;
		IsOrg = isOrg;
	}
}
