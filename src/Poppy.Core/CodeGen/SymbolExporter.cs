// Poppy Compiler - Symbol File Exporter
// Copyright Â© 2026

using Poppy.Core.Semantics;
using System.Text;

namespace Poppy.Core.CodeGen;

/// <summary>
/// Exports symbol information to various debug file formats.
/// </summary>
public sealed class SymbolExporter {
	private readonly SymbolTable _symbolTable;
	private readonly TargetArchitecture _target;

	/// <summary>
	/// Creates a new symbol exporter.
	/// </summary>
	/// <param name="symbolTable">The symbol table to export.</param>
	/// <param name="target">The target architecture.</param>
	public SymbolExporter(SymbolTable symbolTable, TargetArchitecture target) {
		_symbolTable = symbolTable;
		_target = target;
	}

	/// <summary>
	/// Exports symbols to a file in the specified format.
	/// </summary>
	/// <param name="path">Output file path.</param>
	public void Export(string path) {
		var extension = Path.GetExtension(path).ToLowerInvariant();
		var content = extension switch {
			".nl" => ExportFceuxFormat(),
			".mlb" => ExportMesenFormat(),
			".sym" => ExportGenericFormat(),
			_ => ExportGenericFormat()
		};

		File.WriteAllText(path, content, Encoding.UTF8);
	}

	/// <summary>
	/// Exports symbols in FCEUX .nl format.
	/// </summary>
	/// <returns>Symbol file content.</returns>
	private string ExportFceuxFormat() {
		var sb = new StringBuilder();
		sb.AppendLine("# FCEUX Symbol File");
		sb.AppendLine($"# Generated by Poppy Compiler");
		sb.AppendLine();

		foreach (var symbol in _symbolTable.Symbols.Values.OrderBy(s => s.Value ?? 0)) {
			if (!symbol.IsDefined || !symbol.Value.HasValue) continue;
			if (symbol.Type == SymbolType.Macro) continue; // Skip macros

			var address = symbol.Value.Value;
			var name = symbol.Name;
			var comment = GetSymbolComment(symbol);

			sb.AppendLine($"${address:X4}#{name}#{comment}");
		}

		return sb.ToString();
	}

	/// <summary>
	/// Exports symbols in Mesen .mlb format.
	/// </summary>
	/// <returns>Symbol file content.</returns>
	private string ExportMesenFormat() {
		var sb = new StringBuilder();

		foreach (var symbol in _symbolTable.Symbols.Values.OrderBy(s => s.Value ?? 0)) {
			if (!symbol.IsDefined || !symbol.Value.HasValue) continue;
			if (symbol.Type == SymbolType.Macro) continue;

			var address = symbol.Value.Value;
			var name = symbol.Name;
			var region = GetMemoryRegion(address);

			sb.AppendLine($"{region}:${address:X4}:{name}");
		}

		return sb.ToString();
	}

	/// <summary>
	/// Exports symbols in generic .sym format.
	/// </summary>
	/// <returns>Symbol file content.</returns>
	private string ExportGenericFormat() {
		var sb = new StringBuilder();
		sb.AppendLine("; Symbol File");
		sb.AppendLine($"; Generated by Poppy Compiler");
		sb.AppendLine();

		foreach (var symbol in _symbolTable.Symbols.Values.OrderBy(s => s.Value ?? 0)) {
			if (!symbol.IsDefined || !symbol.Value.HasValue) continue;
			if (symbol.Type == SymbolType.Macro) continue;

			var address = symbol.Value.Value;
			var name = symbol.Name;
			var bank = GetBank(address);

			sb.AppendLine($"{bank:X2}:{address:X4} {name}");
		}

		return sb.ToString();
	}

	/// <summary>
	/// Gets a comment describing the symbol.
	/// </summary>
	private string GetSymbolComment(Symbol symbol) {
		return symbol.Type switch {
			SymbolType.Label => "Label",
			SymbolType.Constant => "Constant",
			_ => "Symbol"
		};
	}

	/// <summary>
	/// Gets the memory region classification for Mesen format.
	/// </summary>
	private string GetMemoryRegion(long address) {
		// NES memory map
		if (_target == TargetArchitecture.MOS6502) {
			return address switch {
				< 0x2000 => "RAM",     // Internal RAM
				< 0x8000 => "REG",     // PPU/APU registers, cartridge space
				_ => "PRG"             // PRG ROM
			};
		}

		// SNES memory map (simplified)
		if (_target == TargetArchitecture.WDC65816) {
			return address switch {
				< 0x2000 => "WRAM",
				_ => "PRG"
			};
		}

		// Game Boy memory map
		if (_target == TargetArchitecture.SM83) {
			return address switch {
				< 0x8000 => "ROM",
				< 0xa000 => "VRAM",
				< 0xc000 => "SRAM",
				_ => "WRAM"
			};
		}

		return "PRG";
	}

	/// <summary>
	/// Gets the bank number for an address.
	/// </summary>
	private byte GetBank(long address) {
		// Simple bank calculation (16KB banks for NES)
		if (_target == TargetArchitecture.MOS6502) {
			if (address >= 0x8000) {
				return (byte)((address - 0x8000) / 0x4000);
			}
		}

		return 0;
	}
}
