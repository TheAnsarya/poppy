# Session 12 - Enhanced CDL Generation (2026-01-19)

## Overview

Implemented instruction-based jump/call target tracking for CDL generation (Poppy #125).

## Changes Made

### CdlGenerator.cs Enhancements

- Added `HashSet<long> _jsrTargets` to track JSR/JSL/CALL targets
- Added `HashSet<long> _jmpTargets` to track JMP/JML/BRA/BRL targets
- Added `RegisterSubroutineEntry(long targetAddress)` method
- Added `RegisterJumpTarget(long targetAddress)` method
- Modified `Generate()` to apply tracked targets to CDL output
- Both Mesen and FCEUX formats now use tracked targets

### CodeGenerator.cs Integration

- Added optional `CdlGenerator? _cdlGenerator` field
- Modified constructor to accept optional `cdlGenerator` parameter
- Added tracking logic in instruction emission:
  - Detects JSR/JSL/CALL/BSR instructions → registers as subroutine entry
  - Detects JMP/JML/BRA/BRL instructions → registers as jump target
  - Tracks operand value (target address)

### Previous Implementation

The original implementation used symbol naming conventions:
```csharp
if (name.StartsWith("sub_") || name.StartsWith("fn_") || name.StartsWith("func_")) {
	flags |= MESEN_SUB_ENTRY_POINT;
}
```

### New Implementation

Now tracks actual instruction targets:
```csharp
if (mnemonicLower is "jsr" or "jsl" or "call" or "bsr") {
	_cdlGenerator.RegisterSubroutineEntry(operandValue.Value);
}
else if (mnemonicLower is "jmp" or "jml" or "bra" or "brl") {
	_cdlGenerator.RegisterJumpTarget(operandValue.Value);
}
```

## Improvements

1. **Accuracy**: Marks actual instruction targets, not just symbol names
2. **Automatic**: No manual labeling required
3. **Backward Compatible**: Symbol name detection still works
4. **Peony Integration**: Enhanced CDL files improve disassembly accuracy
5. **Multi-Architecture**: Works for NES (6502), SNES (65816), GB (SM83), etc.

## Opcodes Tracked

### 6502/NES
- JSR $nnnn → 0x20 (Subroutine call)
- JMP $nnnn → 0x4c (Direct jump)
- JMP ($nnnn) → 0x6c (Indirect jump)

### 65816/SNES
- JSR $nnnn → 0x20
- JSL $nnnnnn → 0x22
- JMP $nnnn → 0x4c
- JML $nnnnnn → 0x5c
- BRA label → 0x80
- BRL label → 0x82

### Other Platforms
- CALL (Z80, SM83)
- BSR (68000)

## Testing

- All 1603 tests passing
- No regressions
- Backward compatible API

## CLI Integration

Added `--cdl-detailed` CLI flag:
- Added `CdlDetailed` property to `CompilerOptions`
- Added argument parsing for `--cdl-detailed`
- Updated help text with new option
- Modified `Compile()` method to:
  1. Create CdlGenerator before code generation when detailed tracking is enabled
  2. Pass CdlGenerator to CodeGenerator constructor
  3. Use `CopyTargetsFrom()` to transfer tracked targets to export generator
  4. Display statistics in verbose mode

### New CdlGenerator Methods

```csharp
// Copy targets from code generation phase
public void CopyTargetsFrom(CdlGenerator source)

// Get tracking statistics
public int SubroutineEntryCount => _jsrTargets.Count;
public int JumpTargetCount => _jmpTargets.Count;
```

### Usage

```bash
# Standard CDL generation (symbol-based only)
poppy --cdl output.cdl game.pasm

# Enhanced CDL with instruction tracking
poppy --cdl output.cdl --cdl-detailed game.pasm

# Verbose output shows statistics
poppy --cdl output.cdl --cdl-detailed -V game.pasm
# Output: CDL: output.cdl (mesen format, detailed: 42 subs, 18 jumps)
```

## Remaining Work (Issue #125)

- [x] Implement instruction-based jump/call target tracking
- [x] Add `--cdl-detailed` CLI flag for extended CDL output
- [ ] Implement indirect jump table detection
- [ ] Test with real ROM projects
- [ ] Update documentation with usage examples

## Related Issues

- Poppy #125 - Enhanced CDL generation with jump/call target tracking

## What's Next

1. Test with DW4, FFMQ, DQ3r projects
2. Compare output with Peony disassembly
3. Close issue #125
4. Move to Atari 2600 epic (#120)

